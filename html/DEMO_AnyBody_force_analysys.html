
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_AnyBody_force_analysis</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-09-12"><meta name="DC.source" content="DEMO_AnyBody_force_analysys.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_AnyBody_force_analysis</h1><!--introduction--><p>Below is a demonstration for importing AnyBody surface models and analysis results using the <tt>import_STL_txt</tt> and <tt>importAnyBodyOutput</tt> functions respectively. The analysis results includes loads which can be used for finite element analysis. The surface model is meshed using Tetgen and used to formulate an FEBio model with AnyBody derived boundary conditions.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#5">Importing STL surface triangulation</a></li><li><a href="#6">Visualizing imported surface mesh</a></li><li><a href="#7">Merging nodes</a></li><li><a href="#8">Search for "three-connected" points</a></li><li><a href="#10">Removing "3-connected" vertices in the middle of faces and replacing associated faces by a single face</a></li><li><a href="#12">Surface smoothening</a></li><li><a href="#14">Mesh using TetGen</a></li><li><a href="#16">MESH MODEL USING TETGEN</a></li><li><a href="#19">Import force data</a></li><li><a href="#20">Snap force vector origins to nodes (inaccurate but used anyway for example)</a></li><li><a href="#22">CONSTRUCTING FEB MODEL</a></li><li><a href="#23">SAVING .FEB FILE</a></li><li><a href="#24">RUNNING FEBIO JOB</a></li></ul></div><p><b>N.B. This example shows the pipeline for importing AnyBody metrics and for meshing and FEBio model construction. The actual analysis performed is INACCURATE at present. However the various steps highlighted do illustrate the entire modelling proces. This example will be updated in the future to demonstrate a more realistic analysis.</b> 2014/10/09</p><pre class="codeinput">close <span class="string">all</span>; clc; <span class="comment">%clear;</span>
</pre><p>Plot settings</p><pre class="codeinput">fontSize=10;
faceColor1=<span class="string">'r'</span>;
faceColor2=<span class="string">'g'</span>;
faceAlpha1=1;
faceAlpha2=0.25;
edgeColor=0*ones(1,3);
edgeWidth=0.5;
markerSize=50;
viewAz=65;
vieEl=25;
cMap=jet(250);
</pre><p>path names</p><pre class="codeinput">filePath=mfilename(<span class="string">'fullpath'</span>);
savePath=fullfile(fileparts(filePath),<span class="string">'data'</span>,<span class="string">'temp'</span>);

modelName=fullfile(savePath,<span class="string">'tempModel'</span>);
</pre><h2 id="5">Importing STL surface triangulation</h2><pre class="codeinput"><span class="comment">% Set folder and file name</span>
defaultFolder = fileparts(mfilename(<span class="string">'fullpath'</span>));
pathName=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'STL'</span>);
fileName=fullfile(pathName,<span class="string">'femur.stl'</span>);

<span class="comment">% Import STL</span>
[stlStruct] = import_STL_txt(fileName);
</pre><h2 id="6">Visualizing imported surface mesh</h2><p>Plotting the model</p><pre class="codeinput">cFigure;
title(<span class="string">'Imported patch data from multi-solid STL'</span>,<span class="string">'fontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'fontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'fontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'fontSize'</span>,fontSize); hold <span class="string">on</span>;
<span class="keyword">for</span> q=1:1:numel(stlStruct.solidNames)
    F=stlStruct.solidFaces{q};
    V=stlStruct.solidVertices{q};
    V=V*1000; <span class="comment">% Convert to mm for this particular surface</span>
    patch(<span class="string">'Faces'</span>,F,<span class="string">'Vertices'</span>,V,<span class="string">'FaceColor'</span>,faceColor1,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);
<span class="keyword">end</span>
view(3); axis <span class="string">equal</span>; axis <span class="string">tight</span>; axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>);
lighting <span class="string">phong</span>;
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_01.png" alt=""> <h2 id="7">Merging nodes</h2><p>STL imported surfaces suffer from non-unique points since each face is defined with its own coordinate set, even if it shares nodes with an adjacent face. Hence in order to generate a closed surface these nodes need to be merged. Here the <tt>unique</tt> function is used combined with <tt>pround</tt> to achieve this. So effectively points are deemed the same if they are the same after rounding to the 5th decimal place.</p><pre class="codeinput">[~,ind1,ind2]=unique(pround(V,5),<span class="string">'rows'</span>);
V=V(ind1,:);
F=ind2(F);
</pre><h2 id="8">Search for "three-connected" points</h2><p>A common issue in triangulated surfaces are "three-connected" nodes. These may be undesirable and can easily be identified and removed.</p><pre class="codeinput">[N]=numConnect(F,V);
logicThree=N==3;
</pre><p>Plotting three connected points (some may be boundary points)</p><pre class="codeinput">cFigure;
title(<span class="string">'Highlighted points that are "three-connected"'</span>,<span class="string">'fontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'fontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'fontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'fontSize'</span>,fontSize); hold <span class="string">on</span>;

patch(<span class="string">'Faces'</span>,F,<span class="string">'Vertices'</span>,V,<span class="string">'FaceColor'</span>,faceColor1,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);
plotV(V(logicThree,:),<span class="string">'b.'</span>,<span class="string">'MarkerSize'</span>,markerSize);

view(3); axis <span class="string">equal</span>; axis <span class="string">tight</span>; axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_02.png" alt=""> <h2 id="10">Removing "3-connected" vertices in the middle of faces and replacing associated faces by a single face</h2><p>In a surface triangulation "3-connected" locations often contain poor quality triangles of a locally smaller area then the rest of the surface. Smoothening does not resolve this issue since the quality is not great improved even after vertex is at the centre of its neighbouring nodes. Hence the function triSurfRemoveThreeConnect instead removes the central nodes and groups the affected triangles into a single triangle.</p><pre class="codeinput">[Ft,Vt,~,L]=triSurfRemoveThreeConnect(F,V,[]);
C=double(L);
</pre><p>Plotting results</p><pre class="codeinput">hf=cFigure; hold <span class="string">on</span>;
subplot(1,2,1);
title(<span class="string">'Surface containing split triangles'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hp=patch(<span class="string">'Faces'</span>,F,<span class="string">'Vertices'</span>,V,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,C,<span class="string">'FaceAlpha'</span>,faceAlpha1,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
set(gca,<span class="string">'FontSize'</span>,fontSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
colormap(cMap);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;

subplot(1,2,2);
title(<span class="string">'Restored surface'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hp=patch(<span class="string">'Faces'</span>,Ft,<span class="string">'Vertices'</span>,Vt,<span class="string">'FaceColor'</span>,faceColor2,<span class="string">'FaceAlpha'</span>,faceAlpha1,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
<span class="comment">% [hp]=patchNormPlot(Ft,Vt,0.25);</span>
set(gca,<span class="string">'FontSize'</span>,fontSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;

drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_03.png" alt=""> <h2 id="12">Surface smoothening</h2><pre class="codeinput">cPar.n=25;
cPar.Method=<span class="string">'HC'</span>;
[Vt]=patchSmooth(Ft,Vt,[],cPar);
</pre><p>Plotting smoothing results</p><pre class="codeinput">hf=cFigure; hold <span class="string">on</span>;
subplot(1,2,1);
title(<span class="string">'Unsmoothened surface'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hp=patch(<span class="string">'Faces'</span>,F,<span class="string">'Vertices'</span>,V,<span class="string">'FaceColor'</span>,faceColor1,<span class="string">'FaceAlpha'</span>,faceAlpha1,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
set(gca,<span class="string">'FontSize'</span>,fontSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;

subplot(1,2,2);
title(<span class="string">'Smoothened surface'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hp=patch(<span class="string">'Faces'</span>,Ft,<span class="string">'Vertices'</span>,Vt,<span class="string">'FaceColor'</span>,faceColor2,<span class="string">'FaceAlpha'</span>,faceAlpha1,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
set(gca,<span class="string">'FontSize'</span>,fontSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_04.png" alt=""> <h2 id="14">Mesh using TetGen</h2><pre class="codeinput"><span class="comment">%Find interior point</span>
searchRadius=5;
voxelSize=3;
[V_in_1]=getInnerPoint(Ft,Vt,searchRadius,voxelSize,0);

hf=cFigure; hold <span class="string">on</span>;
title(<span class="string">'Surface model and interior point'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hp=patch(<span class="string">'Faces'</span>,Ft,<span class="string">'Vertices'</span>,Vt,<span class="string">'FaceColor'</span>,faceColor2,<span class="string">'FaceAlpha'</span>,faceAlpha2,<span class="string">'edgeColor'</span>,<span class="string">'none'</span>);
plotV(V_in_1,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);

set(gca,<span class="string">'FontSize'</span>,fontSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  axis <span class="string">vis3d</span>; grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_05.png" alt=""> <pre class="codeinput"><span class="comment">%Face boundary markers</span>
faceBoundaryMarker=ones(size(Ft,1),1);
regionA=tetVolMeanEst(Ft,Vt);
regionA=regionA*6;

stringOpt=<span class="string">'-pq1VAaY'</span>;
smeshName=[<span class="string">'anyBody_FEMUR'</span>,<span class="string">'.smesh'</span>];
smeshStruct.stringOpt=stringOpt;
smeshStruct.Faces=Ft;
smeshStruct.Nodes=Vt;
smeshStruct.holePoints=[];
smeshStruct.faceBoundaryMarker=faceBoundaryMarker; <span class="comment">%Face boundary markers</span>
smeshStruct.regionPoints=V_in_1; <span class="comment">%region points</span>
smeshStruct.regionA=regionA;
smeshStruct.minRegionMarker=2; <span class="comment">%Minimum region marker</span>
smeshStruct.smeshName=smeshName;
</pre><h2 id="16">MESH MODEL USING TETGEN</h2><pre class="codeinput">[meshOutput]=runTetGenSmesh(smeshStruct);
runTetView(meshOutput.loadNameStruct.loadName_ele);
</pre><pre class="codeoutput">Warning: runTetGenSmesh has been renamed to runTetGen. runTetGenSmesh will be
removed in future releases. 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- TETGEN Tetrahedral meshing --- 12-Sep-2016 10:12:38
Warning: smeshStruct.smeshName input will be replaced by smeshStruct.modelName
in future releases! 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing SMESH file --- 12-Sep-2016 10:12:38
Warning: smeshStruct.smeshName input will be replaced by smeshStruct.modelName
in future releases! 
----&gt; Adding node field
----&gt; Adding facet field
----&gt; Adding holes specification
----&gt; Adding region specification
--- Done --- 12-Sep-2016 10:12:38
--- Running TetGen to mesh input boundary--- 12-Sep-2016 10:12:38
Opening D:\MATLAB\SVN\GIBBON\lib_ext\tetGen\tempFiles\anyBody_FEMUR.smesh. 
  Initializing memorypools. 
  tetrahedron per block: 8188. 
  Size of a point: 128 bytes. 
  Size of a tetrahedron: 112 (112) bytes. 
  Size of a shellface: 192 (192) bytes. 
  Initializing robust predicates. 
  sizeof(double) =  8 
  machine epsilon =  2.22045e-016 [IEEE 754 64-bit macheps] 
Delaunizing vertices... 
  Permuting vertices. 
  Sorting vertices. 
  Incrementally inserting vertices. 
Delaunay seconds:  0.015 
  Point sorting seconds:  0 
Creating surface mesh ... 
  5916 (8874) subfaces (segments). 
Surface mesh seconds:  0.005 
Recovering boundaries... 
  Recovering segments. 
  8874 (0) segments are recovered (missing). 
  Recovering facets. 
  5916 (0) subfaces are recovered (missing). 
Boundary recovery seconds:  0.006 
  Segment recovery seconds:  0.004 
  Facet recovery seconds:  0.002 
Removing exterior tetrahedra ... 
Spreading region attributes. 
  Found 1 domain. 
Exterior tets removal seconds:  0.007 
Recovering Delaunayness... 
  Initial obj = 1144577110755.3479 
  Final obj  = 1144577101956.8596 
Delaunay recovery seconds:  0.003 
Refining mesh... 
  Min radiu-edge ratio = 1. 
  Min dihedral   angle = 0. 
  Splitting bad quality tets. 
  Added 5765 (0,0,5765) Steiner points. 
  Performed 2 flips. 
Refinement seconds:  0.132 
Optimizing mesh... 
  Optimization level  = 2. 
  Optimization scheme = 7. 
  Number of iteration = 3. 
  Min_Max dihed angle = 165. 
  Removed 558 edges. 
Optimization seconds:  0.016 
 
Writing D:\MATLAB\SVN\GIBBON\lib_ext\tetGen\tempFiles\anyBody_FEMUR.1.node. 
Writing D:\MATLAB\SVN\GIBBON\lib_ext\tetGen\tempFiles\anyBody_FEMUR.1.ele. 
Writing D:\MATLAB\SVN\GIBBON\lib_ext\tetGen\tempFiles\anyBody_FEMUR.1.face. 
Writing D:\MATLAB\SVN\GIBBON\lib_ext\tetGen\tempFiles\anyBody_FEMUR.1.edge. 
 
Output seconds:  0.091 
Total running seconds:  0.276 
 
Statistics: 
 
  Input points: 2960 
  Input facets: 5916 
  Input segments: 8874 
  Input holes: 0 
  Input regions: 1 
 
  Mesh points: 8725 
  Mesh tetrahedra: 44809 
  Mesh faces: 92576 
  Mesh faces on exterior boundary: 5916 
  Mesh faces on input facets: 5916 
  Mesh edges on input segments: 8874 
  Steiner points inside domain: 5765 
 
Mesh quality statistics: 
 
  Smallest volume:          0.72062   |  Largest volume:            89.37 
  Shortest edge:             1.9158   |  Longest edge:             11.878 
  Smallest asp.ratio:        1.2386   |  Largest asp.ratio:        17.937 
  Smallest facangle:         11.701   |  Largest facangle:       154.2220 
  Smallest dihedral:         5.7235   |  Largest dihedral:       172.3646 
 
  Aspect ratio histogram: 
         &lt; 1.5       :      1197      |      6 - 10         :       645 
     1.5 - 2         :     15650      |     10 - 15         :        41 
       2 - 2.5       :     16692      |     15 - 25         :         5 
     2.5 - 3         :      6230      |     25 - 50         :         0 
       3 - 4         :      2997      |     50 - 100        :         0 
       4 - 6         :      1352      |    100 -            :         0 
  (A tetrahedron's aspect ratio is its longest edge length divided by its 
    smallest side height) 
 
  Face angle histogram: 
      0 -  10 degrees:         0      |     90 - 100 degrees:      9964 
     10 -  20 degrees:        17      |    100 - 110 degrees:      3421 
     20 -  30 degrees:      1236      |    110 - 120 degrees:       625 
     30 -  40 degrees:     24445      |    120 - 130 degrees:        80 
     40 -  50 degrees:     58962      |    130 - 140 degrees:        15 
     50 -  60 degrees:     65267      |    140 - 150 degrees:         2 
     60 -  70 degrees:     57846      |    150 - 160 degrees:         1 
     70 -  80 degrees:     34511      |    160 - 170 degrees:         0 
     80 -  90 degrees:     21336      |    170 - 180 degrees:         0 
 
  Dihedral angle histogram: 
       0 -  5 degrees:         0      |     80 - 110 degrees:     59006 
       5 - 10 degrees:       125      |    110 - 120 degrees:      8350 
      10 - 20 degrees:      3664      |    120 - 130 degrees:      4973 
      20 - 30 degrees:      6987      |    130 - 140 degrees:      3275 
      30 - 40 degrees:     15602      |    140 - 150 degrees:      1996 
      40 - 50 degrees:     32655      |    150 - 160 degrees:      1477 
      50 - 60 degrees:     47035      |    160 - 170 degrees:       541 
      60 - 70 degrees:     47629      |    170 - 175 degrees:         1 
      70 - 80 degrees:     35538      |    175 - 180 degrees:         0 
  Minimum input dihedral angle is 130.66 (degree). 
 
 
Memory usage statistics: 
 
  Maximum number of tetrahedra:  51254 
  Maximum number of tet blocks (blocksize = 8188):  7 
  Approximate memory for tetrahedral mesh (bytes):  11,400,736 
  Approximate memory for extra pointers (bytes):  1,715,408 
  Approximate memory for algorithms (bytes):  3,483,728 
  Approximate memory for working arrays (bytes):  1,371,088 
  Approximate total used memory (bytes):  17,970,960 
 
--- Done --- 12-Sep-2016 10:12:40
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Importing TetGen files --- 12-Sep-2016 10:12:40
--- Done --- 12-Sep-2016 10:12:40
</pre><p>Access model element and patch data</p><pre class="codeinput">F=meshOutput.faces;
V=meshOutput.nodes;
C=meshOutput.faceMaterialID;
E=meshOutput.elements;
elementMaterialIndices=ones(size(E,1),1);
Fb=meshOutput.facesBoundary;
</pre><p>Show model</p><pre class="codeinput"><span class="comment">%Selecting half of the model to see interior</span>
Z=V(:,3); ZE=mean(Z(E),2);
logicCut=ZE&lt;mean(Z);
[Fs,Cs]=element2patch(E(logicCut,:),C(logicCut));

hf1=cFigure;
title(<span class="string">'Cut view of Solid tetrahedral mesh model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
patch(<span class="string">'Faces'</span>,Fs,<span class="string">'Vertices'</span>,V,<span class="string">'FaceColor'</span>,faceColor1,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
patch(<span class="string">'Faces'</span>,Fb,<span class="string">'Vertices'</span>,V,<span class="string">'FaceColor'</span>,faceColor2,<span class="string">'FaceAlpha'</span>,faceAlpha2,<span class="string">'edgeColor'</span>,<span class="string">'none'</span>);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
view(viewAz,vieEl);
colormap(cMap);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);
drawnow;
</pre><pre class="codeoutput">tet4 elements assumed, for other elements please specify elementType
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_06.png" alt=""> <h2 id="19">Import force data</h2><pre class="codeinput">pathName_TXT=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'AnyBody'</span>);
fileName=fullfile(pathName_TXT,<span class="string">'femurData.txt'</span>);
structOut = importAnyBodyOutput(fileName);

F_vec=structOut(1).F; <span class="comment">%Force vectors</span>
Fm=sqrt(sum(F_vec.^2,2));
V_vec=structOut(1).Pos; <span class="comment">%Position vectors</span>
V_vec=V_vec*1000; <span class="comment">%Conver to meters</span>

logicRelevant=Fm&gt;(max(Fm)/100); <span class="comment">%Make a selection of higher forces for now</span>

a=150*[min(Fm(logicRelevant)) max(Fm(logicRelevant))]./max(Fm(logicRelevant)); <span class="comment">%Arrow length scaling to magnitude range</span>
[Ff,Vf,Cf]=quiver3Dpatch(V_vec(logicRelevant,1),V_vec(logicRelevant,2),V_vec(logicRelevant,3),F_vec(logicRelevant,1),F_vec(logicRelevant,2),F_vec(logicRelevant,3),Fm(logicRelevant),a);

hf1=cFigure;
title(<span class="string">'Model surface and force vectors'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
patch(<span class="string">'Faces'</span>,Ft,<span class="string">'Vertices'</span>,Vt,<span class="string">'FaceColor'</span>,faceColor2,<span class="string">'FaceAlpha'</span>,faceAlpha2,<span class="string">'edgeColor'</span>,<span class="string">'none'</span>);
patch(<span class="string">'Faces'</span>,Ff,<span class="string">'Vertices'</span>,Vf,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>, <span class="string">'CData'</span>,Cf,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'FaceAlpha'</span>,1);
colormap(cMap); colorbar;
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;

set(gca,<span class="string">'FontSize'</span>,fontSize);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_07.png" alt=""> <h2 id="20">Snap force vector origins to nodes (inaccurate but used anyway for example)</h2><pre class="codeinput">[~,bcPrescribeList]=minDist(V_vec,V);
bcPrescribeList=bcPrescribeList(logicRelevant);
bcPrescribeMagnitudes=F_vec(logicRelevant,:);
</pre><pre class="codeinput"><span class="comment">% % Bottom boundary region</span>
<span class="comment">% indBoundary=unique(Fb(:));</span>
<span class="comment">% minY=min(V(:,2));</span>
<span class="comment">% maxY=max(V(:,2));</span>
<span class="comment">% w=maxY-minY;</span>
<span class="comment">% bcRigidList=indBoundary(V(indBoundary,2)&lt;(minY+w/30));</span>

<span class="comment">% %Central node</span>
Vm=mean(V,1);
<span class="comment">% [~,bcRigidList]=minDist(Vm,V);</span>

<span class="comment">%Top and bottom</span>
[~,bcRigidList1]=max(V(:,2));
[~,bcRigidList2]=min(V(:,2));
bcRigidList=[bcRigidList1; bcRigidList2];

hf1=cFigure;
title(<span class="string">'Model surface and supported node'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
patch(<span class="string">'Faces'</span>,Ft,<span class="string">'Vertices'</span>,Vt,<span class="string">'FaceColor'</span>,faceColor2,<span class="string">'FaceAlpha'</span>,faceAlpha2,<span class="string">'edgeColor'</span>,<span class="string">'none'</span>);
plotV(V(bcRigidList,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
plotV(Vm,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
view(viewAz,vieEl);
camlight(<span class="string">'headlight'</span>); lighting <span class="string">flat</span>;

set(gca,<span class="string">'FontSize'</span>,fontSize);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_AnyBody_force_analysys_08.png" alt=""> <h2 id="22">CONSTRUCTING FEB MODEL</h2><pre class="codeinput">FEB_struct.febio_spec.version=<span class="string">'2.0'</span>;
FEB_struct.Module.Type=<span class="string">'solid'</span>;

<span class="comment">% Defining file names</span>
FEB_struct.run_filename=[modelName,<span class="string">'.feb'</span>]; <span class="comment">%FEB file name</span>
FEB_struct.run_logname=[modelName,<span class="string">'.txt'</span>]; <span class="comment">%FEBio log file name</span>

<span class="comment">%Geometry section</span>
FEB_struct.Geometry.Nodes=V;
FEB_struct.Geometry.Elements={E}; <span class="comment">%The element sets</span>
FEB_struct.Geometry.ElementType={<span class="string">'tet4'</span>}; <span class="comment">%The element types</span>
FEB_struct.Geometry.ElementMat={elementMaterialIndices};
FEB_struct.Geometry.ElementsPartName={<span class="string">'Femur'</span>};

<span class="comment">%Material section</span>
c1=1e25; <span class="comment">%Very high for now</span>
k=1e2*c1;
FEB_struct.Materials{1}.Type=<span class="string">'Mooney-Rivlin'</span>;
FEB_struct.Materials{1}.Properties={<span class="string">'c1'</span>,<span class="string">'c2'</span>,<span class="string">'k'</span>};
FEB_struct.Materials{1}.Values={c1,0,k};

<span class="comment">%Step specific control sections</span>
FEB_struct.Control.AnalysisType=<span class="string">'static'</span>;
FEB_struct.Control.Properties={<span class="string">'time_steps'</span>,<span class="string">'step_size'</span>,<span class="keyword">...</span>
    <span class="string">'max_refs'</span>,<span class="string">'max_ups'</span>,<span class="keyword">...</span>
    <span class="string">'dtol'</span>,<span class="string">'etol'</span>,<span class="string">'rtol'</span>,<span class="string">'lstol'</span>};
n_steps=50; time_step=1/n_steps;
FEB_struct.Control.Values={n_steps,time_step,<span class="keyword">...</span>
    25,10,<span class="keyword">...</span>
    0.001,0.01,0,0.9};
FEB_struct.Control.TimeStepperProperties={<span class="string">'dtmin'</span>,<span class="string">'dtmax'</span>,<span class="string">'max_retries'</span>,<span class="string">'opt_iter'</span>,<span class="string">'aggressiveness'</span>};
FEB_struct.Control.TimeStepperValues={time_step/1000,time_step, 5, 10, 1};

<span class="comment">%Defining node sets</span>
FEB_struct.Geometry.NodeSet{1}.Set=bcRigidList;
FEB_struct.Geometry.NodeSet{1}.Name=<span class="string">'bcRigidList'</span>;
FEB_struct.Geometry.NodeSet{2}.Set=bcPrescribeList;
FEB_struct.Geometry.NodeSet{2}.Name=<span class="string">'bcPrescribeList'</span>;

<span class="comment">%Adding BC information</span>
FEB_struct.Boundary.Fix{1}.bc=<span class="string">'x'</span>;
FEB_struct.Boundary.Fix{1}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{2}.bc=<span class="string">'y'</span>;
FEB_struct.Boundary.Fix{2}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{3}.bc=<span class="string">'z'</span>;
FEB_struct.Boundary.Fix{3}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{4}.bc=<span class="string">'u'</span>;
FEB_struct.Boundary.Fix{4}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{5}.bc=<span class="string">'v'</span>;
FEB_struct.Boundary.Fix{5}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{6}.bc=<span class="string">'w'</span>;
FEB_struct.Boundary.Fix{6}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;

<span class="comment">%Adding load information</span>
FEB_struct.Loads.Nodal_load{1}.bc=<span class="string">'x'</span>;
FEB_struct.Loads.Nodal_load{1}.lc=1;
<span class="comment">% FEB_struct.Loads.Nodal_load{1}.SetName=FEB_struct.Geometry.NodeSet{2}.Name;</span>
FEB_struct.Loads.Nodal_load{1}.Set=bcPrescribeList;
FEB_struct.Loads.Nodal_load{1}.nodeScale=bcPrescribeMagnitudes(:,1);

FEB_struct.Loads.Nodal_load{2}.bc=<span class="string">'y'</span>;
FEB_struct.Loads.Nodal_load{2}.lc=1;
<span class="comment">% FEB_struct.Loads.Nodal_load{2}.SetName=FEB_struct.Geometry.NodeSet{2}.Name;</span>
FEB_struct.Loads.Nodal_load{2}.Set=bcPrescribeList;
FEB_struct.Loads.Nodal_load{2}.nodeScale=bcPrescribeMagnitudes(:,2);

FEB_struct.Loads.Nodal_load{3}.bc=<span class="string">'z'</span>;
FEB_struct.Loads.Nodal_load{3}.lc=1;
<span class="comment">% FEB_struct.Loads.Nodal_load{3}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;</span>
FEB_struct.Loads.Nodal_load{3}.Set=bcPrescribeList;
FEB_struct.Loads.Nodal_load{3}.nodeScale=bcPrescribeMagnitudes(:,3);

<span class="comment">%Load curves</span>
FEB_struct.LoadData.LoadCurves.id=1;
FEB_struct.LoadData.LoadCurves.type={<span class="string">'linear'</span>};
FEB_struct.LoadData.LoadCurves.loadPoints={[0 0;1 1;]};

<span class="comment">%Adding output requests</span>
FEB_struct.Output.VarTypes={<span class="string">'displacement'</span>,<span class="string">'stress'</span>,<span class="string">'relative volume'</span>};

<span class="comment">%Specify log file output</span>
run_node_output_name=[FEB_struct.run_filename(1:end-4),<span class="string">'_node_out.txt'</span>];
FEB_struct.run_output_names={run_node_output_name};
FEB_struct.output_types={<span class="string">'node_data'</span>};
FEB_struct.data_types={<span class="string">'ux;uy;uz'</span>};
</pre><h2 id="23">SAVING .FEB FILE</h2><pre class="codeinput">FEB_struct.disp_opt=0; <span class="comment">%Display waitbars</span>
febStruct2febFile(FEB_struct);
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing FEBio XML object --- 12-Sep-2016 10:12:43
Adding Module level
Adding Control level
Adding Globals level
Adding Material level
Adding Geometry level
----&gt; Adding node field
----&gt; Adding element field
----&gt; Adding tet4 element entries....
----&gt; Adding NodeSet field
Adding Boundary level
----&gt; Defining fix type boundary conditions
Adding Loads level
----&gt; Defining node loads
----&gt; Adding nodal loads
----&gt; Adding nodal loads
----&gt; Adding nodal loads
Adding LoadData level
----&gt; Defining load curves
Adding Output level
----&gt; Adding plotfile field
----&gt; Adding logfile field
Warning: Provided path of logfile is replaced by .feb file path. Only provide
filename to avoid this warning 
Writing .feb file
--- Done --- 12-Sep-2016 10:12:46
</pre><h2 id="24">RUNNING FEBIO JOB</h2><pre class="codeinput">FEBioRunStruct.run_filename=FEB_struct.run_filename;
FEBioRunStruct.run_logname=FEB_struct.run_logname;
FEBioRunStruct.disp_on=1;
FEBioRunStruct.disp_log_on=1;
FEBioRunStruct.runMode=<span class="string">'external'</span>;<span class="comment">%'internal';</span>
FEBioRunStruct.t_check=0.25; <span class="comment">%Time for checking log file (dont set too small)</span>
FEBioRunStruct.maxtpi=1e99; <span class="comment">%Max analysis time</span>
FEBioRunStruct.maxLogCheckTime=3; <span class="comment">%Max log file checking time</span>

<span class="comment">% [runFlag]=runMonitorFEBio(FEBioRunStruct);%START FEBio NOW!!!!!!!!</span>
</pre><p>if runFlag==1 %i.e. a succesful run     %% IMPORTING NODAL DISPLACEMENT RESULTS     % Importing nodal displacements from a log file     [~, N_disp_mat,~]=importFEBio_logfile(FEB_struct.run_output_names{1}); %Nodal displacements</p><pre>   DN=N_disp_mat(:,2:end,end); %Final nodal displacements</pre><pre>   %% CREATING NODE SET IN DEFORMED STATE
   V_def=V+DN;
   DN_magnitude=sqrt(sum(DN.^2,2));</pre><pre>   %%
   % Plotting the deformed model</pre><pre>   [CF]=vertexToFaceMeasure(Fb,DN_magnitude);</pre><pre>   hf1=figuremax(figColor,figColorDef);
   title('The deformed model','FontSize',fontSize);
   xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;</pre><pre>   hps=patch('Faces',Fb,'Vertices',V_def,'FaceColor','flat','CData',CF);</pre><pre>   view(3); axis tight;  axis equal;  grid on;
   colormap jet; colorbar;
   % camlight headlight;
   set(gca,'FontSize',fontSize);
   drawnow;
end</pre><p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_AnyBody_force_analysis
% Below is a demonstration for importing AnyBody surface models and
% analysis results using the |import_STL_txt| and |importAnyBodyOutput|
% functions respectively. The analysis results includes loads which can be
% used for finite element analysis. The surface model is meshed using
% Tetgen and used to formulate an FEBio model with AnyBody derived boundary
% conditions. 
%% 
% *N.B. This example shows the pipeline for importing AnyBody metrics and
% for meshing and FEBio model construction. The actual analysis performed
% is INACCURATE at present. However the various steps highlighted do
% illustrate the entire modelling proces. This example will be updated in
% the future to demonstrate a more realistic analysis.*
% 2014/10/09

%%
close all; clc; %clear;

%%
% Plot settings
fontSize=10;
faceColor1='r';
faceColor2='g';
faceAlpha1=1;
faceAlpha2=0.25;
edgeColor=0*ones(1,3);
edgeWidth=0.5;
markerSize=50;
viewAz=65;
vieEl=25;
cMap=jet(250);

%%
% path names
filePath=mfilename('fullpath');
savePath=fullfile(fileparts(filePath),'data','temp');

modelName=fullfile(savePath,'tempModel');

%% Importing STL surface triangulation

% Set folder and file name
defaultFolder = fileparts(mfilename('fullpath'));
pathName=fullfile(defaultFolder,'data','STL'); 
fileName=fullfile(pathName,'femur.stl'); 

% Import STL
[stlStruct] = import_STL_txt(fileName);

%% Visualizing imported surface mesh
% Plotting the model

cFigure;
title('Imported patch data from multi-solid STL','fontSize',fontSize);
xlabel('X','fontSize',fontSize);ylabel('Y','fontSize',fontSize); zlabel('Z','fontSize',fontSize); hold on;
for q=1:1:numel(stlStruct.solidNames)
    F=stlStruct.solidFaces{q};
    V=stlStruct.solidVertices{q};        
    V=V*1000; % Convert to mm for this particular surface
    patch('Faces',F,'Vertices',V,'FaceColor',faceColor1,'EdgeColor','k','FaceAlpha',faceAlpha1);
end
view(3); axis equal; axis tight; axis vis3d; grid on;
view(viewAz,vieEl);
camlight('headlight');
lighting phong; 
drawnow;

%% Merging nodes
% STL imported surfaces suffer from non-unique points since each face is
% defined with its own coordinate set, even if it shares nodes with an
% adjacent face. Hence in order to generate a closed surface these nodes
% need to be merged. Here the |unique| function is used combined with
% |pround| to achieve this. So effectively points are deemed the same if
% they are the same after rounding to the 5th decimal place. 

[~,ind1,ind2]=unique(pround(V,5),'rows');
V=V(ind1,:);
F=ind2(F);

%% Search for "three-connected" points
% A common issue in triangulated surfaces are "three-connected" nodes.
% These may be undesirable and can easily be identified and removed. 

[N]=numConnect(F,V);
logicThree=N==3; 

%%
% Plotting three connected points (some may be boundary points)

cFigure;
title('Highlighted points that are "three-connected"','fontSize',fontSize);
xlabel('X','fontSize',fontSize);ylabel('Y','fontSize',fontSize); zlabel('Z','fontSize',fontSize); hold on;

patch('Faces',F,'Vertices',V,'FaceColor',faceColor1,'EdgeColor','k','FaceAlpha',faceAlpha1);
plotV(V(logicThree,:),'b.','MarkerSize',markerSize);

view(3); axis equal; axis tight; axis vis3d; grid on;
view(viewAz,vieEl);
camlight('headlight'); lighting flat; 
drawnow;

%% Removing "3-connected" vertices in the middle of faces and replacing associated faces by a single face
% In a surface triangulation "3-connected" locations often contain poor
% quality triangles of a locally smaller area then the rest of the surface.
% Smoothening does not resolve this issue since the quality is not great
% improved even after vertex is at the centre of its neighbouring nodes.
% Hence the function triSurfRemoveThreeConnect instead removes the central
% nodes and groups the affected triangles into a single triangle. 

[Ft,Vt,~,L]=triSurfRemoveThreeConnect(F,V,[]);
C=double(L);

%%
% Plotting results

hf=cFigure; hold on;
subplot(1,2,1); 
title('Surface containing split triangles','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hp=patch('Faces',F,'Vertices',V,'FaceColor','flat','CData',C,'FaceAlpha',faceAlpha1,'lineWidth',edgeWidth,'edgeColor',edgeColor);
set(gca,'FontSize',fontSize);
view(3); axis tight;  axis equal;  axis vis3d; grid on; 
view(viewAz,vieEl);
colormap(cMap); 
camlight('headlight'); lighting flat;

subplot(1,2,2); 
title('Restored surface','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hp=patch('Faces',Ft,'Vertices',Vt,'FaceColor',faceColor2,'FaceAlpha',faceAlpha1,'lineWidth',edgeWidth,'edgeColor',edgeColor);
% [hp]=patchNormPlot(Ft,Vt,0.25);
set(gca,'FontSize',fontSize);
view(3); axis tight;  axis equal;  axis vis3d; grid on; 
view(viewAz,vieEl);
camlight('headlight'); lighting flat;

drawnow; 

%% Surface smoothening

cPar.n=25;
cPar.Method='HC';
[Vt]=patchSmooth(Ft,Vt,[],cPar);

%%
% Plotting smoothing results

hf=cFigure; hold on;
subplot(1,2,1); 
title('Unsmoothened surface','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hp=patch('Faces',F,'Vertices',V,'FaceColor',faceColor1,'FaceAlpha',faceAlpha1,'lineWidth',edgeWidth,'edgeColor',edgeColor);
set(gca,'FontSize',fontSize);
view(3); axis tight;  axis equal;  axis vis3d; grid on; 
view(viewAz,vieEl);
camlight('headlight'); lighting flat;

subplot(1,2,2); 
title('Smoothened surface','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hp=patch('Faces',Ft,'Vertices',Vt,'FaceColor',faceColor2,'FaceAlpha',faceAlpha1,'lineWidth',edgeWidth,'edgeColor',edgeColor);
set(gca,'FontSize',fontSize);
view(3); axis tight;  axis equal;  axis vis3d; grid on; 
view(viewAz,vieEl);
camlight('headlight'); lighting flat;
drawnow; 

%% Mesh using TetGen

%Find interior point
searchRadius=5;
voxelSize=3; 
[V_in_1]=getInnerPoint(Ft,Vt,searchRadius,voxelSize,0);

hf=cFigure; hold on;
title('Surface model and interior point','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hp=patch('Faces',Ft,'Vertices',Vt,'FaceColor',faceColor2,'FaceAlpha',faceAlpha2,'edgeColor','none');
plotV(V_in_1,'k.','MarkerSize',markerSize);

set(gca,'FontSize',fontSize);
view(3); axis tight;  axis equal;  axis vis3d; grid on; 
view(viewAz,vieEl);
camlight('headlight'); lighting flat;
drawnow; 

%%

%Face boundary markers
faceBoundaryMarker=ones(size(Ft,1),1);
regionA=tetVolMeanEst(Ft,Vt);
regionA=regionA*6;

stringOpt='-pq1VAaY'; 
smeshName=['anyBody_FEMUR','.smesh'];
smeshStruct.stringOpt=stringOpt;
smeshStruct.Faces=Ft; 
smeshStruct.Nodes=Vt; 
smeshStruct.holePoints=[];
smeshStruct.faceBoundaryMarker=faceBoundaryMarker; %Face boundary markers
smeshStruct.regionPoints=V_in_1; %region points
smeshStruct.regionA=regionA; 
smeshStruct.minRegionMarker=2; %Minimum region marker
smeshStruct.smeshName=smeshName; 

%% MESH MODEL USING TETGEN

[meshOutput]=runTetGenSmesh(smeshStruct);
runTetView(meshOutput.loadNameStruct.loadName_ele);

%% 
% Access model element and patch data
F=meshOutput.faces;
V=meshOutput.nodes;
C=meshOutput.faceMaterialID;
E=meshOutput.elements;
elementMaterialIndices=ones(size(E,1),1);
Fb=meshOutput.facesBoundary;

%% 
% Show model

%Selecting half of the model to see interior
Z=V(:,3); ZE=mean(Z(E),2);
logicCut=ZE<mean(Z);
[Fs,Cs]=element2patch(E(logicCut,:),C(logicCut));

hf1=cFigure;
title('Cut view of Solid tetrahedral mesh model','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
patch('Faces',Fs,'Vertices',V,'FaceColor',faceColor1,'lineWidth',edgeWidth,'edgeColor',edgeColor);
patch('Faces',Fb,'Vertices',V,'FaceColor',faceColor2,'FaceAlpha',faceAlpha2,'edgeColor','none');
view(3); axis tight;  axis equal;  grid on;
view(viewAz,vieEl);
colormap(cMap); 
camlight('headlight'); lighting flat;
set(gca,'FontSize',fontSize);
drawnow;

%% Import force data

pathName_TXT=fullfile(defaultFolder,'data','AnyBody'); 
fileName=fullfile(pathName_TXT,'femurData.txt');
structOut = importAnyBodyOutput(fileName);

F_vec=structOut(1).F; %Force vectors
Fm=sqrt(sum(F_vec.^2,2));
V_vec=structOut(1).Pos; %Position vectors
V_vec=V_vec*1000; %Conver to meters

logicRelevant=Fm>(max(Fm)/100); %Make a selection of higher forces for now

a=150*[min(Fm(logicRelevant)) max(Fm(logicRelevant))]./max(Fm(logicRelevant)); %Arrow length scaling to magnitude range
[Ff,Vf,Cf]=quiver3Dpatch(V_vec(logicRelevant,1),V_vec(logicRelevant,2),V_vec(logicRelevant,3),F_vec(logicRelevant,1),F_vec(logicRelevant,2),F_vec(logicRelevant,3),Fm(logicRelevant),a);

hf1=cFigure;
title('Model surface and force vectors','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
patch('Faces',Ft,'Vertices',Vt,'FaceColor',faceColor2,'FaceAlpha',faceAlpha2,'edgeColor','none');
patch('Faces',Ff,'Vertices',Vf,'EdgeColor','k', 'CData',Cf,'FaceColor','flat','FaceAlpha',1); 
colormap(cMap); colorbar; 
view(3); axis tight;  axis equal;  grid on;
view(viewAz,vieEl);
camlight('headlight'); lighting flat;

set(gca,'FontSize',fontSize);
drawnow;

%% Snap force vector origins to nodes (inaccurate but used anyway for example)

[~,bcPrescribeList]=minDist(V_vec,V);
bcPrescribeList=bcPrescribeList(logicRelevant);
bcPrescribeMagnitudes=F_vec(logicRelevant,:);

%%

% % Bottom boundary region
% indBoundary=unique(Fb(:));
% minY=min(V(:,2)); 
% maxY=max(V(:,2)); 
% w=maxY-minY;
% bcRigidList=indBoundary(V(indBoundary,2)<(minY+w/30));

% %Central node
Vm=mean(V,1);
% [~,bcRigidList]=minDist(Vm,V);

%Top and bottom
[~,bcRigidList1]=max(V(:,2));
[~,bcRigidList2]=min(V(:,2));
bcRigidList=[bcRigidList1; bcRigidList2];

hf1=cFigure;
title('Model surface and supported node','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
patch('Faces',Ft,'Vertices',Vt,'FaceColor',faceColor2,'FaceAlpha',faceAlpha2,'edgeColor','none');
plotV(V(bcRigidList,:),'k.','MarkerSize',markerSize);
plotV(Vm,'r.','MarkerSize',markerSize);
view(3); axis tight;  axis equal;  grid on;
view(viewAz,vieEl);
camlight('headlight'); lighting flat;

set(gca,'FontSize',fontSize);
drawnow;

%% CONSTRUCTING FEB MODEL

FEB_struct.febio_spec.version='2.0';
FEB_struct.Module.Type='solid';

% Defining file names
FEB_struct.run_filename=[modelName,'.feb']; %FEB file name
FEB_struct.run_logname=[modelName,'.txt']; %FEBio log file name

%Geometry section
FEB_struct.Geometry.Nodes=V;
FEB_struct.Geometry.Elements={E}; %The element sets
FEB_struct.Geometry.ElementType={'tet4'}; %The element types
FEB_struct.Geometry.ElementMat={elementMaterialIndices};
FEB_struct.Geometry.ElementsPartName={'Femur'};

%Material section
c1=1e25; %Very high for now
k=1e2*c1;
FEB_struct.Materials{1}.Type='Mooney-Rivlin';
FEB_struct.Materials{1}.Properties={'c1','c2','k'};
FEB_struct.Materials{1}.Values={c1,0,k};

%Step specific control sections
FEB_struct.Control.AnalysisType='static';
FEB_struct.Control.Properties={'time_steps','step_size',...
    'max_refs','max_ups',...
    'dtol','etol','rtol','lstol'};
n_steps=50; time_step=1/n_steps;
FEB_struct.Control.Values={n_steps,time_step,...
    25,10,...
    0.001,0.01,0,0.9};
FEB_struct.Control.TimeStepperProperties={'dtmin','dtmax','max_retries','opt_iter','aggressiveness'};
FEB_struct.Control.TimeStepperValues={time_step/1000,time_step, 5, 10, 1};

%Defining node sets
FEB_struct.Geometry.NodeSet{1}.Set=bcRigidList;
FEB_struct.Geometry.NodeSet{1}.Name='bcRigidList';
FEB_struct.Geometry.NodeSet{2}.Set=bcPrescribeList;
FEB_struct.Geometry.NodeSet{2}.Name='bcPrescribeList';

%Adding BC information
FEB_struct.Boundary.Fix{1}.bc='x';
FEB_struct.Boundary.Fix{1}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{2}.bc='y';
FEB_struct.Boundary.Fix{2}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{3}.bc='z';
FEB_struct.Boundary.Fix{3}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{4}.bc='u';
FEB_struct.Boundary.Fix{4}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{5}.bc='v';
FEB_struct.Boundary.Fix{5}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{6}.bc='w';
FEB_struct.Boundary.Fix{6}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;

%Adding load information
FEB_struct.Loads.Nodal_load{1}.bc='x';
FEB_struct.Loads.Nodal_load{1}.lc=1;
% FEB_struct.Loads.Nodal_load{1}.SetName=FEB_struct.Geometry.NodeSet{2}.Name;
FEB_struct.Loads.Nodal_load{1}.Set=bcPrescribeList;
FEB_struct.Loads.Nodal_load{1}.nodeScale=bcPrescribeMagnitudes(:,1);

FEB_struct.Loads.Nodal_load{2}.bc='y';
FEB_struct.Loads.Nodal_load{2}.lc=1;
% FEB_struct.Loads.Nodal_load{2}.SetName=FEB_struct.Geometry.NodeSet{2}.Name;
FEB_struct.Loads.Nodal_load{2}.Set=bcPrescribeList;
FEB_struct.Loads.Nodal_load{2}.nodeScale=bcPrescribeMagnitudes(:,2);

FEB_struct.Loads.Nodal_load{3}.bc='z';
FEB_struct.Loads.Nodal_load{3}.lc=1;
% FEB_struct.Loads.Nodal_load{3}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Loads.Nodal_load{3}.Set=bcPrescribeList;
FEB_struct.Loads.Nodal_load{3}.nodeScale=bcPrescribeMagnitudes(:,3);

%Load curves
FEB_struct.LoadData.LoadCurves.id=1;
FEB_struct.LoadData.LoadCurves.type={'linear'};
FEB_struct.LoadData.LoadCurves.loadPoints={[0 0;1 1;]};

%Adding output requests
FEB_struct.Output.VarTypes={'displacement','stress','relative volume'};

%Specify log file output
run_node_output_name=[FEB_struct.run_filename(1:end-4),'_node_out.txt'];
FEB_struct.run_output_names={run_node_output_name};
FEB_struct.output_types={'node_data'};
FEB_struct.data_types={'ux;uy;uz'};

%% SAVING .FEB FILE

FEB_struct.disp_opt=0; %Display waitbars
febStruct2febFile(FEB_struct);

%% RUNNING FEBIO JOB

FEBioRunStruct.run_filename=FEB_struct.run_filename;
FEBioRunStruct.run_logname=FEB_struct.run_logname;
FEBioRunStruct.disp_on=1;
FEBioRunStruct.disp_log_on=1;
FEBioRunStruct.runMode='external';%'internal';
FEBioRunStruct.t_check=0.25; %Time for checking log file (dont set too small)
FEBioRunStruct.maxtpi=1e99; %Max analysis time
FEBioRunStruct.maxLogCheckTime=3; %Max log file checking time

% [runFlag]=runMonitorFEBio(FEBioRunStruct);%START FEBio NOW!!!!!!!!

%%
% if runFlag==1 %i.e. a succesful run
%     %% IMPORTING NODAL DISPLACEMENT RESULTS
%     % Importing nodal displacements from a log file
%     [~, N_disp_mat,~]=importFEBio_logfile(FEB_struct.run_output_names{1}); %Nodal displacements
%     
%     DN=N_disp_mat(:,2:end,end); %Final nodal displacements
%     
%     %% CREATING NODE SET IN DEFORMED STATE
%     V_def=V+DN;
%     DN_magnitude=sqrt(sum(DN.^2,2));
%     
%     %%
%     % Plotting the deformed model
%     
%     [CF]=vertexToFaceMeasure(Fb,DN_magnitude);
%     
%     hf1=figuremax(figColor,figColorDef);
%     title('The deformed model','FontSize',fontSize);
%     xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
%     
%     hps=patch('Faces',Fb,'Vertices',V_def,'FaceColor','flat','CData',CF);
%     
%     view(3); axis tight;  axis equal;  grid on;
%     colormap jet; colorbar;
%     % camlight headlight;
%     set(gca,'FontSize',fontSize);
%     drawnow;
% end

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>

##### SOURCE END #####
--></body></html>