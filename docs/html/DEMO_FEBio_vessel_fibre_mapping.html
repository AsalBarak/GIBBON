
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_FEBIO_vessel_fibre_mapping</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-01-19"><meta name="DC.source" content="DEMO_FEBio_vessel_fibre_mapping.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_FEBIO_vessel_fibre_mapping</h1><!--introduction--><p>Below is a demonstration of how to map, set and import fibre directions for FEBio.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#5">BUILDING EXAMPLE SURFACE GEOMETRY</a></li><li><a href="#7">CAPPING MODEL</a></li><li><a href="#9">JOINING MODEL COMPONENTS</a></li><li><a href="#11">MESHING THE MODEL</a></li><li><a href="#16">Visualizing mesh</a></li><li><a href="#19">CREATING FIBRE DIRECTIONS</a></li><li><a href="#21">DEFINE PRESCRIBED DISPLACEMENTS</a></li><li><a href="#22">DEFINE BOUNDARY CONDITIONS</a></li><li><a href="#25">CONSTRUCTING FEB MODEL</a></li><li><a href="#26">SAVING .FEB FILE</a></li><li><a href="#27">RUNNING FEBIO JOB</a></li><li><a href="#28">IMPORTING NODAL DISPLACEMENT RESULTS</a></li><li><a href="#29">CREATING NODE SET IN DEFORMED STATE</a></li><li><a href="#31">DERIVE FIBRE DIRECTIONS IN DEFORMED STATE</a></li></ul></div><p>A vessel model is constructed consisting of two layers with different mechanical properties and fibre directions. The inner wall of the vessel is subjected to a prescribed displacement. Fibre directions are set in the .feb file, the model is run in FEBio, results are exported and the fibre directions in the deformed state are derived from the imported model results.</p><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><p>Plot settings</p><pre class="codeinput">fontSize=15;
faceAlpha1=0.5;
faceAlpha2=0.5;
edgeColor=0.25*ones(1,3);
edgeWidth=1.5;
markerSize1=50;
cMap=gjet(250);

<span class="comment">% path names</span>
defaultFolder = fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)));
savePath=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'temp'</span>);
</pre><p>Control parameters</p><pre class="codeinput"><span class="comment">%Material parameters</span>
c1_1=0.0006618290645;
m1_1=2.0000011857416;
ksi_1=0.0000906045135;
beta_1=3.1728247084040;
f_1=229.9578182262337;
k_factor=500;
k_1=(c1_1+ksi_1)*k_factor;

c1_2=2*0.0006618290645;
m1_2=2.0000011857416;
ksi_2=2*0.0000906045135;
beta_2=3.1728247084040;
f_2=229.9578182262337;
k_factor=500;
k_2=(c1_2+ksi_2)*k_factor;

<span class="comment">%FEA control settings</span>
nSteps=10; <span class="comment">%Number of time steps desired</span>
max_refs=25; <span class="comment">%Max reforms</span>
max_ups=0; <span class="comment">%Set to zero to use full-Newton iterations</span>
opt_iter=6; <span class="comment">%Optimum number of iterations</span>
max_retries=5; <span class="comment">%Maximum number of retires</span>
dtmin=(1/nSteps)/100; <span class="comment">%Minimum time step size</span>
dtmax=1/nSteps; <span class="comment">%Maximum time step size</span>
</pre><h2 id="5">BUILDING EXAMPLE SURFACE GEOMETRY</h2><pre class="codeinput"><span class="comment">% Construct regular cylinder</span>
r=10;
nr=25;
h=35;
nz=15;
ptype=<span class="string">'tri'</span>;
[Fc,Vc]=patchcylinder(r,nr,h,nz,ptype);

<span class="comment">%Top edge indices</span>
It=ones(nr,1); Jt=(1:1:nr)';
INDt=sub2ind([nz,nr],It,Jt);

<span class="comment">%Bottom edge indices</span>
Ib=nz.*ones(nr,1); Jb=(1:1:nr)';
INDb=sub2ind([nz,nr],Ib,Jb);

<span class="comment">% Deforming regular cylinder to create outer wall</span>
V1=Vc;
F1=Fc;

<span class="comment">% Creating the first inner wall</span>
[T,R,Z]=cart2pol(V1(:,1),V1(:,2),V1(:,3));
R2=R-2;
V2=V1;
F2=Fc;
[V2(:,1),V2(:,2),V2(:,3)]=pol2cart(T,R2,Z);

<span class="comment">% Creating the second inner wall</span>
[T,R,Z]=cart2pol(V2(:,1),V2(:,2),V2(:,3));
R3=R-2;
V3=V2;
F3=Fc;
[V3(:,1),V3(:,2),V3(:,3)]=pol2cart(T,R3,Z);
</pre><p>Plotting the example model surfaces</p><pre class="codeinput">hf1=cFigure;
title(<span class="string">'Cylindrical surfaces of the model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;
patch(<span class="string">'Faces'</span>,F1,<span class="string">'Vertices'</span>,V1,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceAlpha'</span>,1);
patch(<span class="string">'Faces'</span>,F2,<span class="string">'Vertices'</span>,V2,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'g'</span>,<span class="string">'FaceAlpha'</span>,1);
patch(<span class="string">'Faces'</span>,F3,<span class="string">'Vertices'</span>,V3,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'b'</span>,<span class="string">'FaceAlpha'</span>,1);

<span class="comment">% patchNormPlot(F1,V1);</span>
<span class="comment">% patchNormPlot(F2,V2);</span>
<span class="comment">% patchNormPlot(F3,V3);</span>

axis <span class="string">equal</span>; view(3); axis <span class="string">tight</span>;  grid <span class="string">on</span>; set(gca,<span class="string">'FontSize'</span>,fontSize);
camlight(<span class="string">'headlight'</span>);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_01.png" alt=""> <h2 id="7">CAPPING MODEL</h2><pre class="codeinput">pointSpacingCap=2;
regionSpec{1}={V1(INDt,[1 2]),V2(INDt,[1 2])};
regionSpec{2}={V2(INDt,[1 2]),V3(INDt,[1 2])};
[Ft,Vt,regionInd_t]=multiRegionTriMesh2D(regionSpec,pointSpacingCap,0,0);
Vt(:,3)=min(V1(:,3));

regionSpec{1}={V1(INDb,[1 2]),V2(INDb,[1 2])};
regionSpec{2}={V2(INDb,[1 2]),V3(INDb,[1 2])};
[Fb,Vb,regionInd_b]=multiRegionTriMesh2D(regionSpec,pointSpacingCap,0,0);
Vb(:,3)=max(V1(:,3));
</pre><p>Plotting the example model surfaces</p><pre class="codeinput">hf1=cFigure;
title(<span class="string">'Capped model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

patch(<span class="string">'Faces'</span>,F1,<span class="string">'Vertices'</span>,V1,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);
plotV(V1(INDb,:),<span class="string">'b.-'</span>,<span class="string">'MarkerSize'</span>,25,<span class="string">'LineWidth'</span>,3);
plotV(V1(INDt,:),<span class="string">'b.-'</span>,<span class="string">'MarkerSize'</span>,25,<span class="string">'LineWidth'</span>,3);
patch(<span class="string">'Faces'</span>,F2,<span class="string">'Vertices'</span>,V2,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'g'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);
patch(<span class="string">'Faces'</span>,F3,<span class="string">'Vertices'</span>,V3,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'b'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);
patch(<span class="string">'Faces'</span>,Ft,<span class="string">'Vertices'</span>,Vt,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'y'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);
patch(<span class="string">'Faces'</span>,Fb,<span class="string">'Vertices'</span>,Vb,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,<span class="string">'y'</span>,<span class="string">'FaceAlpha'</span>,faceAlpha1);

<span class="comment">% patchNormPlot(F1,V1);</span>
<span class="comment">% patchNormPlot(F2,V2);</span>
<span class="comment">% patchNormPlot(F3,V3);</span>
<span class="comment">% patchNormPlot(Ft,Vt);</span>
<span class="comment">% patchNormPlot(Fb,Vb);</span>

axis <span class="string">equal</span>; view(3); axis <span class="string">tight</span>;  grid <span class="string">on</span>; set(gca,<span class="string">'FontSize'</span>,fontSize);
camlight(<span class="string">'headlight'</span>);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_02.png" alt=""> <h2 id="9">JOINING MODEL COMPONENTS</h2><pre class="codeinput"><span class="comment">%Merge point sets</span>
V=[V1;V2;V3;Vt;Vb];

F=[F1;<span class="keyword">...</span><span class="comment"> %Outer surface</span>
    F2+size(V1,1);<span class="keyword">...</span><span class="comment"> %First inner surface</span>
    fliplr(F3)+size(V1,1)+size(V2,1);<span class="keyword">...</span><span class="comment"> %Second inner surface</span>
    fliplr(Ft)+size(V1,1)+size(V2,1)+size(V3,1);<span class="keyword">...</span><span class="comment"> %Caps top</span>
    Fb+size(V1,1)+size(V2,1)+size(V3,1)+size(Vt,1)]; <span class="comment">%Caps bottom</span>

[~,ind1,ind2]=unique(pround(V,5),<span class="string">'rows'</span>);
V=V(ind1,:);
F=ind2(F);

faceBoundaryMarker=[1*ones(size(F1,1),1);<span class="keyword">...</span>
                    2*ones(size(F2,1),1);<span class="keyword">...</span>
                    3*ones(size(F3,1),1);<span class="keyword">...</span>
                    4*ones(nnz(regionInd_t==1),1);<span class="keyword">...</span>
                    5*ones(nnz(regionInd_t==2),1);<span class="keyword">...</span>
                    6*ones(nnz(regionInd_b==1),1);<span class="keyword">...</span>
                    7*ones(nnz(regionInd_b==2),1);<span class="keyword">...</span>
                    ];
</pre><p>Plotting the example model</p><pre class="codeinput">hf1=cFigure;
title(<span class="string">'Merged model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;
hp=patch(<span class="string">'Faces'</span>,F,<span class="string">'Vertices'</span>,V,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,faceBoundaryMarker,<span class="string">'FaceAlpha'</span>,faceAlpha2);
<span class="comment">% patchNormPlot(F,V);</span>

axis <span class="string">equal</span>; view(3); axis <span class="string">tight</span>;  grid <span class="string">on</span>; set(gca,<span class="string">'FontSize'</span>,fontSize);
colormap(cMap); colorbar;
camlight(<span class="string">'headlight'</span>);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_03.png" alt=""> <h2 id="11">MESHING THE MODEL</h2><p>Find mesh interior points</p><pre class="codeinput">searchRadius=3;
voxelSize=1;

logicRegion=(faceBoundaryMarker==1) |<span class="keyword">...</span>
            (faceBoundaryMarker==2) |<span class="keyword">...</span>
            (faceBoundaryMarker==4) |<span class="keyword">...</span>
            (faceBoundaryMarker==6);
[V_in_1]=getInnerPoint(F(logicRegion,:),V,searchRadius,voxelSize,0);
plotV(V_in_1,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize1);
drawnow;

logicRegion=(faceBoundaryMarker==2) |<span class="keyword">...</span>
            (faceBoundaryMarker==3) |<span class="keyword">...</span>
            (faceBoundaryMarker==5) |<span class="keyword">...</span>
            (faceBoundaryMarker==7);
[V_in_2]=getInnerPoint(F(logicRegion,:),V,searchRadius,voxelSize,0);
plotV(V_in_2,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize1);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_04.png" alt=""> <pre class="codeinput">V_regions=[V_in_1;V_in_2;]; <span class="comment">% Define region points</span>
V_holes=[ ]; <span class="comment">%Define holes</span>
regionA=[0.2 0.2]; <span class="comment">% Regional mesh parameters</span>
</pre><p>CREATING THE model STRUCTURE. TetGen can mesh geometries from various mesh file formats. For the GIBBON toolbox .model files have been implemented. Below a structure is created that fully defines such as model file and the meshing settings for TetGen.</p><pre class="codeinput">stringOpt=<span class="string">'-pq1.2AaYQ'</span>;
modelNameEnd=<span class="string">'tempModel'</span>;
modelName=fullfile(savePath,modelNameEnd);

modelStruct.stringOpt=stringOpt;
modelStruct.Faces=F;
modelStruct.Nodes=V;
modelStruct.holePoints=V_holes;
modelStruct.faceBoundaryMarker=faceBoundaryMarker; <span class="comment">%Face boundary markers</span>
modelStruct.regionPoints=V_regions; <span class="comment">%region points</span>
modelStruct.regionA=regionA;
modelStruct.minRegionMarker=2; <span class="comment">%Minimum region marker</span>
modelStruct.modelName=modelName;
</pre><p>Mesh model using tetrahedral elements using tetGen (see: <a href="http://wias-berlin.de/software/tetgen/">http://wias-berlin.de/software/tetgen/</a>)</p><pre class="codeinput">[meshOutput]=runTetGen(modelStruct); <span class="comment">%Run tetGen</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- TETGEN Tetrahedral meshing --- 19-Jan-2018 14:43:48
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing SMESH file --- 19-Jan-2018 14:43:48
----&gt; Adding node field
----&gt; Adding facet field
----&gt; Adding holes specification
----&gt; Adding region specification
--- Done --- 19-Jan-2018 14:43:48
--- Running TetGen to mesh input boundary--- 19-Jan-2018 14:43:48
Opening /mnt/data/MATLAB/GIT/GIBBON/lib_ext/tetGen/tempFiles/tempModel.smesh.
--- Done --- 19-Jan-2018 14:43:48
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Importing TetGen files --- 19-Jan-2018 14:43:48
--- Done --- 19-Jan-2018 14:43:48
</pre><h2 id="16">Visualizing mesh</h2><pre class="codeinput">meshView(meshOutput);
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_05.png" alt=""> <pre class="codeinput"><span class="comment">% Accessing the model element and patch data</span>
FT=meshOutput.faces;
Fb=meshOutput.facesBoundary;
Cb=meshOutput.boundaryMarker;
VT=meshOutput.nodes;
C=meshOutput.faceMaterialID;
E=meshOutput.elements;
elementMaterialIndices=meshOutput.elementMaterialID;
</pre><p>Plotting the meshed geometry</p><pre class="codeinput">hf1=cFigure;
subplot(1,3,1);
title(<span class="string">'Solid tetrahedral mesh model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
hps=patch(<span class="string">'Faces'</span>,FT,<span class="string">'Vertices'</span>,VT,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,C,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
camlight <span class="string">headlight</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);

subplot(1,3,2);
title(<span class="string">'Model boundaries'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
hps=patch(<span class="string">'Faces'</span>,Fb,<span class="string">'Vertices'</span>,VT,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,Cb,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor,<span class="string">'FaceAlpha'</span>,faceAlpha1);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);

subplot(1,3,3);
<span class="comment">%Selecting half of the model to see interior</span>
Y=VT(:,2); YE=mean(Y(E),2);
L=YE&gt;mean(Y);
[Fs,Cs]=element2patch(E(L,:),C(L));
title(<span class="string">'Cut view of solid tetrahedral mesh model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
hps=patch(<span class="string">'Faces'</span>,Fs,<span class="string">'Vertices'</span>,VT,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,Cs,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
camlight <span class="string">headlight</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);

colormap(cMap);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_06.png" alt=""> <h2 id="19">CREATING FIBRE DIRECTIONS</h2><pre class="codeinput"><span class="comment">%Compute coordinates at the centre of elements for fibre origings</span>
X=VT(:,1); Y=VT(:,2); Z=VT(:,3);
XE=mean(X(E),2); YE=mean(Y(E),2); ZE=mean(Z(E),2);
VE=[XE(:) YE(:) ZE(:)];

L1=elementMaterialIndices==-2;
L2=elementMaterialIndices==-3;

zDir=[0 0 1];
VE_XY=VE;
VE_XY(:,3)=0;
VE_XY=vecnormalize(VE_XY);
VF=cross(VE_XY,zDir(ones(size(VE,1),1),:)); <span class="comment">%I.e. radial tangent</span>
VF=vecnormalize(VF);
VF(L1,:)=-VF(L1,:); <span class="comment">%I.e. radial tangent flipped</span>
VF(:,3)=1;
VF=vecnormalize(VF);

<span class="comment">%Create patch data for fibres</span>
[Ff,Vf,Cf]=quiver3Dpatch(VE(:,1),VE(:,2),VE(:,3),VF(:,1),VF(:,2),VF(:,3),ones(size(VF,1),1),[1 1]);
</pre><p>Plotting the example model</p><pre class="codeinput">hf1=cFigure;
title(<span class="string">'Fibre directions clockwise and counter clockwise depending on layer'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;
hp=patch(<span class="string">'Faces'</span>,Fb,<span class="string">'Vertices'</span>,VT,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,Cb,<span class="string">'FaceAlpha'</span>,faceAlpha2);
hp=patch(<span class="string">'Faces'</span>,Ff,<span class="string">'Vertices'</span>,Vf,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceColor'</span>,<span class="string">'k'</span>);
<span class="comment">% plotV(VE,'k.');</span>
axis <span class="string">equal</span>; view(3); axis <span class="string">tight</span>;  grid <span class="string">on</span>; set(gca,<span class="string">'FontSize'</span>,fontSize);
colormap(cMap); colorbar;
set(gca,<span class="string">'FontSize'</span>,fontSize);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_07.png" alt=""> <h2 id="21">DEFINE PRESCRIBED DISPLACEMENTS</h2><pre class="codeinput"><span class="comment">%Get inner surface (numbering may have altered due to tetgen behaviour so</span>
<span class="comment">%redefined here)</span>
F_inner=Fb(Cb==3,:);
indInner=unique(F_inner(:));
V_inner=VT(indInner,:);

<span class="comment">% Defining deformed boundary coordinates</span>
f=abs(V_inner(:,3)-min(VT(:,3)));
f=f./max(f(:));

[THETA,R,Z] = cart2pol(V_inner(:,1),V_inner(:,2),V_inner(:,3));
R=R+2.5*(1-cos(2*pi*f));
V_inner_def=V_inner;
[V_inner_def(:,1),V_inner_def(:,2),V_inner_def(:,3)]=pol2cart(THETA,R,Z);

<span class="comment">% Define boundary displacement values</span>
bcPrescribedMagnitudes=(V_inner_def-V_inner);

<span class="comment">% Define indices (node numbers) for the prescribed displacement</span>
bcPrescribeList=indInner;
</pre><h2 id="22">DEFINE BOUNDARY CONDITIONS</h2><pre class="codeinput">bcFixList=Fb(Cb==4 | Cb==5 | Cb==6 | Cb==7,:);
bcFixList=unique(bcFixList(:));

plotV(VT(bcFixList,:),<span class="string">'k.'</span>);
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_08.png" alt=""> <p>Plotting deformed inner surface</p><pre class="codeinput">C_inner=sqrt(sum(bcPrescribedMagnitudes.^2,2)); <span class="comment">%Color towards displacement magnitude</span>
CV=zeros(size(VT,1),1);
CV(indInner)=C_inner;
[CF]=vertexToFaceMeasure(F_inner,CV);

VT_def=VT;
VT_def(indInner,:)=V_inner_def;

cFigure; hold <span class="string">on</span>;
title(<span class="string">'The deformed inner surface'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);


patch(<span class="string">'Faces'</span>,F_inner,<span class="string">'Vertices'</span>,VT_def,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,CF,<span class="string">'FaceAlpha'</span>,1);
colormap(cMap); colorbar;
camlight <span class="string">headlight</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_09.png" alt=""> <pre class="codeinput">febMatID=elementMaterialIndices;
febMatID(elementMaterialIndices==-2)=1;
febMatID(elementMaterialIndices==-3)=2;
</pre><h2 id="25">CONSTRUCTING FEB MODEL</h2><pre class="codeinput">FEB_struct.febio_spec.version=<span class="string">'2.0'</span>;
FEB_struct.Module.Type=<span class="string">'solid'</span>;

<span class="comment">% Defining file names</span>
FEB_struct.run_filename=[modelName,<span class="string">'.feb'</span>]; <span class="comment">%FEB file name</span>
FEB_struct.run_logname=[modelName,<span class="string">'.txt'</span>]; <span class="comment">%FEBio log file name</span>

<span class="comment">%Geometry section</span>
FEB_struct.Geometry.Nodes=VT;
FEB_struct.Geometry.Elements={E}; <span class="comment">%The element sets</span>
FEB_struct.Geometry.ElementType={<span class="string">'tet4'</span>}; <span class="comment">%The element types</span>
FEB_struct.Geometry.ElementMat={febMatID};
FEB_struct.Geometry.ElementsPartName={<span class="string">'Blood_vessel'</span>};

<span class="comment">%Material section</span>
FEB_struct.Materials{1}.Type=<span class="string">'solid mixture'</span>;
FEB_struct.Materials{1}.Solid{1}.Type=<span class="string">'Ogden unconstrained'</span>;
FEB_struct.Materials{1}.Solid{1}.Properties={<span class="string">'c1'</span>,<span class="string">'m1'</span>,<span class="string">'cp'</span>};
FEB_struct.Materials{1}.Solid{1}.Values={c1_1,m1_1,k_1};

FEB_struct.Materials{1}.Solid{2}.Type=<span class="string">'ellipsoidal fiber distribution'</span>;
FEB_struct.Materials{1}.Solid{2}.Properties={<span class="string">'ksi'</span>,<span class="string">'beta'</span>};
FEB_struct.Materials{1}.Solid{2}.Values={[ksi_1 ksi_1 f_1*ksi_1],[beta_1 beta_1 beta_1]};
FEB_struct.Materials{1}.Solid{2}.AnisoType=<span class="string">'mat_axis'</span>;

FEB_struct.Materials{2}.Type=<span class="string">'solid mixture'</span>;
FEB_struct.Materials{2}.Solid{1}.Type=<span class="string">'Ogden unconstrained'</span>;
FEB_struct.Materials{2}.Solid{1}.Properties={<span class="string">'c1'</span>,<span class="string">'m1'</span>,<span class="string">'cp'</span>};
FEB_struct.Materials{2}.Solid{1}.Values={c1_2,m1_2,k_2};

FEB_struct.Materials{2}.Solid{2}.Type=<span class="string">'ellipsoidal fiber distribution'</span>;
FEB_struct.Materials{2}.Solid{2}.Properties={<span class="string">'ksi'</span>,<span class="string">'beta'</span>};
FEB_struct.Materials{2}.Solid{2}.Values={[ksi_2 ksi_2 f_2*ksi_1],[beta_2 beta_2 beta_2]};
FEB_struct.Materials{2}.Solid{2}.AnisoType=<span class="string">'mat_axis'</span>;

<span class="comment">%Adding fibre direction, construct local orthonormal basis vectors</span>
[a,d]=vectorOrthogonalPair(VF);

VF_E=zeros(size(VF,1),size(VF,2),2);
VF_E(:,:,1)=a; <span class="comment">%a1 ~ e1 ~ X or first direction</span>
VF_E(:,:,2)=d; <span class="comment">%a2 ~ e2 ~ Y or second direction</span>
<span class="comment">%Vf_E %a3 ~ e3 ~ Z, third direction, or fibre direction</span>

FEB_struct.Geometry.ElementData.MatAxis.ElementIndices=1:1:size(E,1);
FEB_struct.Geometry.ElementData.MatAxis.Basis=VF_E;

<span class="comment">%Defining node sets</span>
FEB_struct.Geometry.NodeSet{1}.Set=bcFixList;
FEB_struct.Geometry.NodeSet{1}.Name=<span class="string">'boundaryConditionNodeList'</span>;
<span class="comment">% FEB_struct.Geometry.NodeSet{2}.Set=bcIndicesPrescribed;</span>
<span class="comment">% FEB_struct.Geometry.NodeSet{2}.Name='bcIndicesPrescribed';</span>

<span class="comment">%Adding BC information</span>
FEB_struct.Boundary.Fix{1}.bc=<span class="string">'x'</span>;
FEB_struct.Boundary.Fix{1}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{2}.bc=<span class="string">'y'</span>;
FEB_struct.Boundary.Fix{2}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{3}.bc=<span class="string">'z'</span>;
FEB_struct.Boundary.Fix{3}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;

FEB_struct.Boundary.Prescribe{1}.Set=bcPrescribeList;
FEB_struct.Boundary.Prescribe{1}.bc=<span class="string">'x'</span>;
FEB_struct.Boundary.Prescribe{1}.lc=1;
FEB_struct.Boundary.Prescribe{1}.nodeScale=bcPrescribedMagnitudes(:,1);
FEB_struct.Boundary.Prescribe{1}.Type=<span class="string">'relative'</span>;

FEB_struct.Boundary.Prescribe{2}.Set=bcPrescribeList;
FEB_struct.Boundary.Prescribe{2}.bc=<span class="string">'y'</span>;
FEB_struct.Boundary.Prescribe{2}.lc=1;
FEB_struct.Boundary.Prescribe{2}.nodeScale=bcPrescribedMagnitudes(:,2);
FEB_struct.Boundary.Prescribe{2}.Type=<span class="string">'relative'</span>;

FEB_struct.Boundary.Prescribe{3}.Set=bcPrescribeList;
FEB_struct.Boundary.Prescribe{3}.bc=<span class="string">'z'</span>;
FEB_struct.Boundary.Prescribe{3}.lc=1;
FEB_struct.Boundary.Prescribe{3}.nodeScale=bcPrescribedMagnitudes(:,3);
FEB_struct.Boundary.Prescribe{3}.Type=<span class="string">'relative'</span>;

<span class="comment">%Control section</span>
FEB_struct.Control.AnalysisType=<span class="string">'static'</span>;
FEB_struct.Control.Properties={<span class="string">'time_steps'</span>,<span class="string">'step_size'</span>,<span class="keyword">...</span>
    <span class="string">'max_refs'</span>,<span class="string">'max_ups'</span>,<span class="keyword">...</span>
    <span class="string">'dtol'</span>,<span class="string">'etol'</span>,<span class="string">'rtol'</span>,<span class="string">'lstol'</span>};
FEB_struct.Control.Values={nSteps,1/nSteps,<span class="keyword">...</span>
    max_refs,max_ups,<span class="keyword">...</span>
    0.001,0.01,0,0.9};
FEB_struct.Control.TimeStepperProperties={<span class="string">'dtmin'</span>,<span class="string">'dtmax'</span>,<span class="string">'max_retries'</span>,<span class="string">'opt_iter'</span>};
FEB_struct.Control.TimeStepperValues={dtmin,dtmax,max_retries,opt_iter};

<span class="comment">%Adding output requests</span>
FEB_struct.Output.VarTypes={<span class="string">'displacement'</span>,<span class="string">'stress'</span>,<span class="string">'relative volume'</span>,<span class="string">'shell thickness'</span>};

<span class="comment">%Specify log file output</span>
run_output_name1=[modelNameEnd,<span class="string">'_node_out.txt'</span>];
run_output_name2=[modelNameEnd,<span class="string">'_F_out.txt'</span>];
FEB_struct.run_output_names={run_output_name1,run_output_name2};
FEB_struct.output_types={<span class="string">'node_data'</span>,<span class="string">'element_data'</span>};
FEB_struct.data_types={<span class="string">'ux;uy;uz'</span>,<span class="string">'Fxx;Fxy;Fxz;Fyx;Fyy;Fyz;Fzx;Fzy;Fzz'</span>};

<span class="comment">%Control section</span>
FEB_struct.Control.AnalysisType=<span class="string">'static'</span>;
FEB_struct.Control.Properties={<span class="string">'time_steps'</span>,<span class="string">'step_size'</span>,<span class="keyword">...</span>
    <span class="string">'max_refs'</span>,<span class="string">'max_ups'</span>,<span class="keyword">...</span>
    <span class="string">'dtol'</span>,<span class="string">'etol'</span>,<span class="string">'rtol'</span>,<span class="string">'lstol'</span>};
FEB_struct.Control.Values={10,0.1,<span class="keyword">...</span>
    25,0,<span class="keyword">...</span>
    0.001,0.01,0,0.9};
FEB_struct.Control.TimeStepperProperties={<span class="string">'dtmin'</span>,<span class="string">'dtmax'</span>,<span class="string">'max_retries'</span>,<span class="string">'opt_iter'</span>,<span class="string">'aggressiveness'</span>};
FEB_struct.Control.TimeStepperValues={1e-5, 0.1, 5, 5, 1};

<span class="comment">%Load curves</span>
FEB_struct.LoadData.LoadCurves.id=[1];
FEB_struct.LoadData.LoadCurves.type={<span class="string">'smooth'</span>};
FEB_struct.LoadData.LoadCurves.loadPoints={[0 0;1 1]};
</pre><h2 id="26">SAVING .FEB FILE</h2><pre class="codeinput">FEB_struct.disp_opt=0; <span class="comment">%Turn on displaying of progress</span>
febStruct2febFile(FEB_struct);
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing FEBio XML object --- 19-Jan-2018 14:43:53
Using febio_spec: 2.0
Adding Module level
Adding Control level
Adding Material level
Adding Geometry level
----&gt; Adding node field
----&gt; Adding element field
----&gt; Adding tet4 element entries....
----&gt; Adding element data field
----&gt; MatAxis data entries found
----&gt; Adding NodeSet field
Adding Boundary level
----&gt; Defining fix type boundary conditions
----&gt; Defining prescribe type boundary conditions
Adding LoadData level
----&gt; Defining load curves
Adding Output level
----&gt; Adding plotfile field
----&gt; Adding logfile field
Writing .feb file
--- Done --- 19-Jan-2018 14:43:57
</pre><h2 id="27">RUNNING FEBIO JOB</h2><pre class="codeinput">FEBioRunStruct.run_filename=FEB_struct.run_filename;
FEBioRunStruct.run_logname=FEB_struct.run_logname;
FEBioRunStruct.disp_on=1;
FEBioRunStruct.disp_log_on=1;
FEBioRunStruct.runMode=<span class="string">'external'</span>;<span class="comment">%'internal';</span>
FEBioRunStruct.t_check=0.25; <span class="comment">%Time for checking log file (dont set too small)</span>
FEBioRunStruct.maxtpi=1e99; <span class="comment">%Max analysis time</span>
FEBioRunStruct.maxLogCheckTime=3; <span class="comment">%Max log file checking time</span>

[runFlag]=runMonitorFEBio(FEBioRunStruct);<span class="comment">%START FEBio NOW!!!!!!!!</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- STARTING FEBIO JOB --- 19-Jan-2018 14:43:57
Waiting for log file...
Proceeding to check log file...19-Jan-2018 14:43:57
------- converged at time : 0.1
------- converged at time : 0.2
------- converged at time : 0.3
------- converged at time : 0.4
------- converged at time : 0.5
------- converged at time : 0.6
------- converged at time : 0.7
------- converged at time : 0.8
------- converged at time : 0.9
------- converged at time : 1
--- Done --- 19-Jan-2018 14:43:59
</pre><h2 id="28">IMPORTING NODAL DISPLACEMENT RESULTS</h2><p>Importing nodal displacements from a log file</p><pre class="codeinput">[~, N_disp_mat,~]=importFEBio_logfile(fullfile(savePath,FEB_struct.run_output_names{1})); <span class="comment">%Nodal displacements</span>
DN=N_disp_mat(:,2:end,end); <span class="comment">%Final nodal displacements</span>

<span class="comment">%Import deformation gradient tensors</span>
[~,FG_mat,~]=importFEBio_logfile(fullfile(savePath,FEB_struct.run_output_names{2})); <span class="comment">%Deformation gradient tensors</span>
FG=FG_mat(:,2:end,end);
</pre><h2 id="29">CREATING NODE SET IN DEFORMED STATE</h2><pre class="codeinput">VT_def=VT+DN;
</pre><p>Plotting the FEA results</p><pre class="codeinput">hf=cFigure;
subplot(1,2,1);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;
C=sqrt(sum(DN.^2,2)); <span class="comment">%Color towards displacement magnitude</span>
hps=patch(<span class="string">'Faces'</span>,FT,<span class="string">'Vertices'</span>,VT_def,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,C,<span class="string">'lineWidth'</span>,edgeWidth,<span class="string">'edgeColor'</span>,edgeColor);
view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
camlight <span class="string">headlight</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);

subplot(1,2,2);
title(<span class="string">'Cut view of deformed model showing internal results'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize); hold <span class="string">on</span>;

<span class="comment">%Selecting half of the model to see interior</span>
Z=VT(:,3); ZE=mean(Z(E),2);
L=ZE&lt;mean(Z);
[Fs,~]=element2patch(E(L,:),[]);
Cs=sqrt(sum(DN.^2,2)); <span class="comment">%Color towards displacement magnitude</span>

hps=patch(<span class="string">'Faces'</span>,Fs,<span class="string">'Vertices'</span>,VT_def,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'FaceVertexCData'</span>,Cs);

view(3); axis <span class="string">tight</span>;  axis <span class="string">equal</span>;  grid <span class="string">on</span>;
colormap(cMap); colorbar;
camlight <span class="string">headlight</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_10.png" alt=""> <h2 id="31">DERIVE FIBRE DIRECTIONS IN DEFORMED STATE</h2><pre class="codeinput"><span class="comment">%Compute coordinates at the centre of elements for fibre origings</span>
X=VT_def(:,1); Y=VT_def(:,2); Z=VT_def(:,3);
XE=mean(X(E),2); YE=mean(Y(E),2); ZE=mean(Z(E),2);
VE_def=[XE(:) YE(:) ZE(:)];

VF_def=VF;
<span class="keyword">for</span> q=1:1:size(E,1)

    fg=reshape(FG(q,:),3,3)';

    vn=vecnormalize(fg*VF(q,:)')'; <span class="comment">%Mapped/stretched vector</span>
    VF_def(q,:)=vn;
<span class="keyword">end</span>

<span class="comment">%Create patch data for fibres</span>
[Ff_def,Vf_def,Cf_def]=quiver3Dpatch(VE_def(:,1),VE_def(:,2),VE_def(:,3),VF_def(:,1),VF_def(:,2),VF_def(:,3),ones(size(VF_def,1),1),[1 1]);
</pre><p>Plotting the example model</p><pre class="codeinput">hf1=cFigure;
title(<span class="string">'Fibre directions in the deformed state'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize);ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;
hp=patch(<span class="string">'Faces'</span>,Fb,<span class="string">'Vertices'</span>,VT_def,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceColor'</span>,<span class="string">'flat'</span>,<span class="string">'CData'</span>,Cb,<span class="string">'FaceAlpha'</span>,faceAlpha2);
hp=patch(<span class="string">'Faces'</span>,Ff_def,<span class="string">'Vertices'</span>,Vf_def,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceColor'</span>,<span class="string">'k'</span>);
<span class="comment">% plotV(VE,'k.');</span>
axis <span class="string">equal</span>; view(3); axis <span class="string">tight</span>;  grid <span class="string">on</span>; set(gca,<span class="string">'FontSize'</span>,fontSize);
colormap(cMap); colorbar;
set(gca,<span class="string">'FontSize'</span>,fontSize);
drawnow;
</pre><img vspace="5" hspace="5" src="DEMO_FEBio_vessel_fibre_mapping_11.png" alt=""> <p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2017  Kevin Mattheus Moerman</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_FEBIO_vessel_fibre_mapping
% Below is a demonstration of how to map, set and import fibre directions
% for FEBio.

%%
% A vessel model is constructed consisting of two layers with different
% mechanical properties and fibre directions. The inner wall of the vessel
% is subjected to a prescribed displacement. Fibre directions are set in
% the .feb file, the model is run in FEBio, results are exported and the
% fibre directions in the deformed state are derived from the imported
% model results. 

%%

clear; close all; clc;

%%
% Plot settings
fontSize=15;
faceAlpha1=0.5;
faceAlpha2=0.5;
edgeColor=0.25*ones(1,3);
edgeWidth=1.5;
markerSize1=50; 
cMap=gjet(250);

% path names
defaultFolder = fileparts(fileparts(mfilename('fullpath')));
savePath=fullfile(defaultFolder,'data','temp');

%%
% Control parameters

%Material parameters
c1_1=0.0006618290645;
m1_1=2.0000011857416;
ksi_1=0.0000906045135;
beta_1=3.1728247084040;
f_1=229.9578182262337;
k_factor=500; 
k_1=(c1_1+ksi_1)*k_factor;

c1_2=2*0.0006618290645;
m1_2=2.0000011857416;
ksi_2=2*0.0000906045135;
beta_2=3.1728247084040;
f_2=229.9578182262337;
k_factor=500; 
k_2=(c1_2+ksi_2)*k_factor;

%FEA control settings
nSteps=10; %Number of time steps desired
max_refs=25; %Max reforms
max_ups=0; %Set to zero to use full-Newton iterations
opt_iter=6; %Optimum number of iterations
max_retries=5; %Maximum number of retires
dtmin=(1/nSteps)/100; %Minimum time step size
dtmax=1/nSteps; %Maximum time step size

%% BUILDING EXAMPLE SURFACE GEOMETRY

% Construct regular cylinder
r=10; 
nr=25; 
h=35;
nz=15;
ptype='tri';
[Fc,Vc]=patchcylinder(r,nr,h,nz,ptype);

%Top edge indices
It=ones(nr,1); Jt=(1:1:nr)';
INDt=sub2ind([nz,nr],It,Jt);

%Bottom edge indices
Ib=nz.*ones(nr,1); Jb=(1:1:nr)';
INDb=sub2ind([nz,nr],Ib,Jb);

% Deforming regular cylinder to create outer wall
V1=Vc; 
F1=Fc; 

% Creating the first inner wall
[T,R,Z]=cart2pol(V1(:,1),V1(:,2),V1(:,3));
R2=R-2;
V2=V1;
F2=Fc; 
[V2(:,1),V2(:,2),V2(:,3)]=pol2cart(T,R2,Z);

% Creating the second inner wall
[T,R,Z]=cart2pol(V2(:,1),V2(:,2),V2(:,3));
R3=R-2;
V3=V2;
F3=Fc; 
[V3(:,1),V3(:,2),V3(:,3)]=pol2cart(T,R3,Z);

%%
% Plotting the example model surfaces
hf1=cFigure;
title('Cylindrical surfaces of the model','FontSize',fontSize);
xlabel('X','FontSize',fontSize);ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;
patch('Faces',F1,'Vertices',V1,'EdgeColor','k','FaceColor','r','FaceAlpha',1);
patch('Faces',F2,'Vertices',V2,'EdgeColor','k','FaceColor','g','FaceAlpha',1);
patch('Faces',F3,'Vertices',V3,'EdgeColor','k','FaceColor','b','FaceAlpha',1);

% patchNormPlot(F1,V1);
% patchNormPlot(F2,V2);
% patchNormPlot(F3,V3);

axis equal; view(3); axis tight;  grid on; set(gca,'FontSize',fontSize);
camlight('headlight');
drawnow;

%% CAPPING MODEL

pointSpacingCap=2; 
regionSpec{1}={V1(INDt,[1 2]),V2(INDt,[1 2])};
regionSpec{2}={V2(INDt,[1 2]),V3(INDt,[1 2])};
[Ft,Vt,regionInd_t]=multiRegionTriMesh2D(regionSpec,pointSpacingCap,0,0);
Vt(:,3)=min(V1(:,3));

regionSpec{1}={V1(INDb,[1 2]),V2(INDb,[1 2])};
regionSpec{2}={V2(INDb,[1 2]),V3(INDb,[1 2])};
[Fb,Vb,regionInd_b]=multiRegionTriMesh2D(regionSpec,pointSpacingCap,0,0);
Vb(:,3)=max(V1(:,3));

%%
% Plotting the example model surfaces
hf1=cFigure;
title('Capped model','FontSize',fontSize);
xlabel('X','FontSize',fontSize);ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;

patch('Faces',F1,'Vertices',V1,'EdgeColor','k','FaceColor','r','FaceAlpha',faceAlpha1);
plotV(V1(INDb,:),'b.-','MarkerSize',25,'LineWidth',3);
plotV(V1(INDt,:),'b.-','MarkerSize',25,'LineWidth',3);
patch('Faces',F2,'Vertices',V2,'EdgeColor','k','FaceColor','g','FaceAlpha',faceAlpha1);
patch('Faces',F3,'Vertices',V3,'EdgeColor','k','FaceColor','b','FaceAlpha',faceAlpha1);
patch('Faces',Ft,'Vertices',Vt,'EdgeColor','k','FaceColor','y','FaceAlpha',faceAlpha1);
patch('Faces',Fb,'Vertices',Vb,'EdgeColor','k','FaceColor','y','FaceAlpha',faceAlpha1);

% patchNormPlot(F1,V1);
% patchNormPlot(F2,V2);
% patchNormPlot(F3,V3);
% patchNormPlot(Ft,Vt);
% patchNormPlot(Fb,Vb);

axis equal; view(3); axis tight;  grid on; set(gca,'FontSize',fontSize);
camlight('headlight');
drawnow;

%% JOINING MODEL COMPONENTS

%Merge point sets
V=[V1;V2;V3;Vt;Vb];

F=[F1;... %Outer surface
    F2+size(V1,1);... %First inner surface
    fliplr(F3)+size(V1,1)+size(V2,1);... %Second inner surface
    fliplr(Ft)+size(V1,1)+size(V2,1)+size(V3,1);... %Caps top
    Fb+size(V1,1)+size(V2,1)+size(V3,1)+size(Vt,1)]; %Caps bottom

[~,ind1,ind2]=unique(pround(V,5),'rows');
V=V(ind1,:); 
F=ind2(F);

faceBoundaryMarker=[1*ones(size(F1,1),1);... 
                    2*ones(size(F2,1),1);... 
                    3*ones(size(F3,1),1);...
                    4*ones(nnz(regionInd_t==1),1);...
                    5*ones(nnz(regionInd_t==2),1);...
                    6*ones(nnz(regionInd_b==1),1);...
                    7*ones(nnz(regionInd_b==2),1);...                    
                    ];

%%
% Plotting the example model
hf1=cFigure;
title('Merged model','FontSize',fontSize);
xlabel('X','FontSize',fontSize);ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;
hp=patch('Faces',F,'Vertices',V,'EdgeColor','none','FaceColor','flat','CData',faceBoundaryMarker,'FaceAlpha',faceAlpha2);
% patchNormPlot(F,V);

axis equal; view(3); axis tight;  grid on; set(gca,'FontSize',fontSize);
colormap(cMap); colorbar; 
camlight('headlight');
drawnow;

%% MESHING THE MODEL

%%
% Find mesh interior points
searchRadius=3; 
voxelSize=1;

logicRegion=(faceBoundaryMarker==1) |...
            (faceBoundaryMarker==2) |...
            (faceBoundaryMarker==4) |...
            (faceBoundaryMarker==6);        
[V_in_1]=getInnerPoint(F(logicRegion,:),V,searchRadius,voxelSize,0);
plotV(V_in_1,'k.','MarkerSize',markerSize1);
drawnow;

logicRegion=(faceBoundaryMarker==2) |...
            (faceBoundaryMarker==3) |...
            (faceBoundaryMarker==5) |...
            (faceBoundaryMarker==7);        
[V_in_2]=getInnerPoint(F(logicRegion,:),V,searchRadius,voxelSize,0);
plotV(V_in_2,'k.','MarkerSize',markerSize1);
drawnow;

%%

V_regions=[V_in_1;V_in_2;]; % Define region points
V_holes=[ ]; %Define holes
regionA=[0.2 0.2]; % Regional mesh parameters

%%
% CREATING THE model STRUCTURE. 
% TetGen can mesh geometries from various mesh file formats. For the GIBBON
% toolbox .model files have been implemented. Below a structure is created
% that fully defines such as model file and the meshing settings for
% TetGen. 

stringOpt='-pq1.2AaYQ';
modelNameEnd='tempModel';
modelName=fullfile(savePath,modelNameEnd);

modelStruct.stringOpt=stringOpt;
modelStruct.Faces=F;
modelStruct.Nodes=V;
modelStruct.holePoints=V_holes;
modelStruct.faceBoundaryMarker=faceBoundaryMarker; %Face boundary markers
modelStruct.regionPoints=V_regions; %region points
modelStruct.regionA=regionA;
modelStruct.minRegionMarker=2; %Minimum region marker
modelStruct.modelName=modelName;

%% 
% Mesh model using tetrahedral elements using tetGen (see:
% <http://wias-berlin.de/software/tetgen/>)

[meshOutput]=runTetGen(modelStruct); %Run tetGen

%% Visualizing mesh
meshView(meshOutput);

%%

% Accessing the model element and patch data
FT=meshOutput.faces;
Fb=meshOutput.facesBoundary;
Cb=meshOutput.boundaryMarker;
VT=meshOutput.nodes;
C=meshOutput.faceMaterialID;
E=meshOutput.elements;
elementMaterialIndices=meshOutput.elementMaterialID;

%%
% Plotting the meshed geometry

hf1=cFigure;
subplot(1,3,1);
title('Solid tetrahedral mesh model','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
hps=patch('Faces',FT,'Vertices',VT,'FaceColor','flat','CData',C,'lineWidth',edgeWidth,'edgeColor',edgeColor);
view(3); axis tight;  axis equal;  grid on;
camlight headlight;
set(gca,'FontSize',fontSize);

subplot(1,3,2);
title('Model boundaries','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
hps=patch('Faces',Fb,'Vertices',VT,'FaceColor','flat','CData',Cb,'lineWidth',edgeWidth,'edgeColor',edgeColor,'FaceAlpha',faceAlpha1);
view(3); axis tight;  axis equal;  grid on;
set(gca,'FontSize',fontSize);

subplot(1,3,3);
%Selecting half of the model to see interior
Y=VT(:,2); YE=mean(Y(E),2);
L=YE>mean(Y);
[Fs,Cs]=element2patch(E(L,:),C(L));
title('Cut view of solid tetrahedral mesh model','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
hps=patch('Faces',Fs,'Vertices',VT,'FaceColor','flat','CData',Cs,'lineWidth',edgeWidth,'edgeColor',edgeColor);
view(3); axis tight;  axis equal;  grid on;
camlight headlight;
set(gca,'FontSize',fontSize);

colormap(cMap);
drawnow;

%% CREATING FIBRE DIRECTIONS

%Compute coordinates at the centre of elements for fibre origings
X=VT(:,1); Y=VT(:,2); Z=VT(:,3);
XE=mean(X(E),2); YE=mean(Y(E),2); ZE=mean(Z(E),2);
VE=[XE(:) YE(:) ZE(:)];

L1=elementMaterialIndices==-2; 
L2=elementMaterialIndices==-3; 

zDir=[0 0 1];
VE_XY=VE;
VE_XY(:,3)=0;
VE_XY=vecnormalize(VE_XY);
VF=cross(VE_XY,zDir(ones(size(VE,1),1),:)); %I.e. radial tangent
VF=vecnormalize(VF);
VF(L1,:)=-VF(L1,:); %I.e. radial tangent flipped
VF(:,3)=1; 
VF=vecnormalize(VF);

%Create patch data for fibres
[Ff,Vf,Cf]=quiver3Dpatch(VE(:,1),VE(:,2),VE(:,3),VF(:,1),VF(:,2),VF(:,3),ones(size(VF,1),1),[1 1]);

%%
% Plotting the example model
hf1=cFigure;
title('Fibre directions clockwise and counter clockwise depending on layer','FontSize',fontSize);
xlabel('X','FontSize',fontSize);ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;
hp=patch('Faces',Fb,'Vertices',VT,'EdgeColor','none','FaceColor','flat','CData',Cb,'FaceAlpha',faceAlpha2);
hp=patch('Faces',Ff,'Vertices',Vf,'EdgeColor','none','FaceColor','k');
% plotV(VE,'k.');
axis equal; view(3); axis tight;  grid on; set(gca,'FontSize',fontSize);
colormap(cMap); colorbar; 
set(gca,'FontSize',fontSize);
drawnow;

%% DEFINE PRESCRIBED DISPLACEMENTS

%Get inner surface (numbering may have altered due to tetgen behaviour so
%redefined here)
F_inner=Fb(Cb==3,:); 
indInner=unique(F_inner(:));
V_inner=VT(indInner,:);

% Defining deformed boundary coordinates
f=abs(V_inner(:,3)-min(VT(:,3)));
f=f./max(f(:));

[THETA,R,Z] = cart2pol(V_inner(:,1),V_inner(:,2),V_inner(:,3));
R=R+2.5*(1-cos(2*pi*f));
V_inner_def=V_inner;
[V_inner_def(:,1),V_inner_def(:,2),V_inner_def(:,3)]=pol2cart(THETA,R,Z);

% Define boundary displacement values
bcPrescribedMagnitudes=(V_inner_def-V_inner);

% Define indices (node numbers) for the prescribed displacement
bcPrescribeList=indInner;

%% DEFINE BOUNDARY CONDITIONS

bcFixList=Fb(Cb==4 | Cb==5 | Cb==6 | Cb==7,:);
bcFixList=unique(bcFixList(:));

plotV(VT(bcFixList,:),'k.');

%% 
% Plotting deformed inner surface
C_inner=sqrt(sum(bcPrescribedMagnitudes.^2,2)); %Color towards displacement magnitude
CV=zeros(size(VT,1),1);
CV(indInner)=C_inner;
[CF]=vertexToFaceMeasure(F_inner,CV);

VT_def=VT; 
VT_def(indInner,:)=V_inner_def; 

cFigure; hold on;
title('The deformed inner surface','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);


patch('Faces',F_inner,'Vertices',VT_def,'FaceColor','flat','CData',CF,'FaceAlpha',1);
colormap(cMap); colorbar; 
camlight headlight;
set(gca,'FontSize',fontSize);
view(3); axis tight;  axis equal;  grid on;

%%
febMatID=elementMaterialIndices;
febMatID(elementMaterialIndices==-2)=1;
febMatID(elementMaterialIndices==-3)=2;

%% CONSTRUCTING FEB MODEL

FEB_struct.febio_spec.version='2.0';
FEB_struct.Module.Type='solid';

% Defining file names
FEB_struct.run_filename=[modelName,'.feb']; %FEB file name
FEB_struct.run_logname=[modelName,'.txt']; %FEBio log file name

%Geometry section
FEB_struct.Geometry.Nodes=VT;
FEB_struct.Geometry.Elements={E}; %The element sets
FEB_struct.Geometry.ElementType={'tet4'}; %The element types
FEB_struct.Geometry.ElementMat={febMatID};
FEB_struct.Geometry.ElementsPartName={'Blood_vessel'};

%Material section
FEB_struct.Materials{1}.Type='solid mixture';
FEB_struct.Materials{1}.Solid{1}.Type='Ogden unconstrained';
FEB_struct.Materials{1}.Solid{1}.Properties={'c1','m1','cp'};
FEB_struct.Materials{1}.Solid{1}.Values={c1_1,m1_1,k_1};

FEB_struct.Materials{1}.Solid{2}.Type='ellipsoidal fiber distribution';
FEB_struct.Materials{1}.Solid{2}.Properties={'ksi','beta'};
FEB_struct.Materials{1}.Solid{2}.Values={[ksi_1 ksi_1 f_1*ksi_1],[beta_1 beta_1 beta_1]};
FEB_struct.Materials{1}.Solid{2}.AnisoType='mat_axis';

FEB_struct.Materials{2}.Type='solid mixture';
FEB_struct.Materials{2}.Solid{1}.Type='Ogden unconstrained';
FEB_struct.Materials{2}.Solid{1}.Properties={'c1','m1','cp'};
FEB_struct.Materials{2}.Solid{1}.Values={c1_2,m1_2,k_2};

FEB_struct.Materials{2}.Solid{2}.Type='ellipsoidal fiber distribution';
FEB_struct.Materials{2}.Solid{2}.Properties={'ksi','beta'};
FEB_struct.Materials{2}.Solid{2}.Values={[ksi_2 ksi_2 f_2*ksi_1],[beta_2 beta_2 beta_2]};
FEB_struct.Materials{2}.Solid{2}.AnisoType='mat_axis';

%Adding fibre direction, construct local orthonormal basis vectors
[a,d]=vectorOrthogonalPair(VF);

VF_E=zeros(size(VF,1),size(VF,2),2);
VF_E(:,:,1)=a; %a1 ~ e1 ~ X or first direction
VF_E(:,:,2)=d; %a2 ~ e2 ~ Y or second direction
%Vf_E %a3 ~ e3 ~ Z, third direction, or fibre direction

FEB_struct.Geometry.ElementData.MatAxis.ElementIndices=1:1:size(E,1);
FEB_struct.Geometry.ElementData.MatAxis.Basis=VF_E;

%Defining node sets
FEB_struct.Geometry.NodeSet{1}.Set=bcFixList;
FEB_struct.Geometry.NodeSet{1}.Name='boundaryConditionNodeList';
% FEB_struct.Geometry.NodeSet{2}.Set=bcIndicesPrescribed;
% FEB_struct.Geometry.NodeSet{2}.Name='bcIndicesPrescribed';

%Adding BC information
FEB_struct.Boundary.Fix{1}.bc='x';
FEB_struct.Boundary.Fix{1}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{2}.bc='y';
FEB_struct.Boundary.Fix{2}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;
FEB_struct.Boundary.Fix{3}.bc='z';
FEB_struct.Boundary.Fix{3}.SetName=FEB_struct.Geometry.NodeSet{1}.Name;

FEB_struct.Boundary.Prescribe{1}.Set=bcPrescribeList;
FEB_struct.Boundary.Prescribe{1}.bc='x';
FEB_struct.Boundary.Prescribe{1}.lc=1;
FEB_struct.Boundary.Prescribe{1}.nodeScale=bcPrescribedMagnitudes(:,1);
FEB_struct.Boundary.Prescribe{1}.Type='relative';

FEB_struct.Boundary.Prescribe{2}.Set=bcPrescribeList;
FEB_struct.Boundary.Prescribe{2}.bc='y';
FEB_struct.Boundary.Prescribe{2}.lc=1;
FEB_struct.Boundary.Prescribe{2}.nodeScale=bcPrescribedMagnitudes(:,2);
FEB_struct.Boundary.Prescribe{2}.Type='relative';

FEB_struct.Boundary.Prescribe{3}.Set=bcPrescribeList;
FEB_struct.Boundary.Prescribe{3}.bc='z';
FEB_struct.Boundary.Prescribe{3}.lc=1;
FEB_struct.Boundary.Prescribe{3}.nodeScale=bcPrescribedMagnitudes(:,3);
FEB_struct.Boundary.Prescribe{3}.Type='relative';

%Control section
FEB_struct.Control.AnalysisType='static';
FEB_struct.Control.Properties={'time_steps','step_size',...
    'max_refs','max_ups',...
    'dtol','etol','rtol','lstol'};
FEB_struct.Control.Values={nSteps,1/nSteps,...
    max_refs,max_ups,...
    0.001,0.01,0,0.9};
FEB_struct.Control.TimeStepperProperties={'dtmin','dtmax','max_retries','opt_iter'};
FEB_struct.Control.TimeStepperValues={dtmin,dtmax,max_retries,opt_iter};

%Adding output requests
FEB_struct.Output.VarTypes={'displacement','stress','relative volume','shell thickness'};

%Specify log file output
run_output_name1=[modelNameEnd,'_node_out.txt'];
run_output_name2=[modelNameEnd,'_F_out.txt'];
FEB_struct.run_output_names={run_output_name1,run_output_name2};
FEB_struct.output_types={'node_data','element_data'};
FEB_struct.data_types={'ux;uy;uz','Fxx;Fxy;Fxz;Fyx;Fyy;Fyz;Fzx;Fzy;Fzz'};

%Control section
FEB_struct.Control.AnalysisType='static';
FEB_struct.Control.Properties={'time_steps','step_size',...
    'max_refs','max_ups',...
    'dtol','etol','rtol','lstol'};
FEB_struct.Control.Values={10,0.1,...
    25,0,...
    0.001,0.01,0,0.9};
FEB_struct.Control.TimeStepperProperties={'dtmin','dtmax','max_retries','opt_iter','aggressiveness'};
FEB_struct.Control.TimeStepperValues={1e-5, 0.1, 5, 5, 1};

%Load curves
FEB_struct.LoadData.LoadCurves.id=[1];
FEB_struct.LoadData.LoadCurves.type={'smooth'};
FEB_struct.LoadData.LoadCurves.loadPoints={[0 0;1 1]};

%% SAVING .FEB FILE

FEB_struct.disp_opt=0; %Turn on displaying of progress
febStruct2febFile(FEB_struct);

%% RUNNING FEBIO JOB

FEBioRunStruct.run_filename=FEB_struct.run_filename;
FEBioRunStruct.run_logname=FEB_struct.run_logname;
FEBioRunStruct.disp_on=1;
FEBioRunStruct.disp_log_on=1;
FEBioRunStruct.runMode='external';%'internal';
FEBioRunStruct.t_check=0.25; %Time for checking log file (dont set too small)
FEBioRunStruct.maxtpi=1e99; %Max analysis time
FEBioRunStruct.maxLogCheckTime=3; %Max log file checking time

[runFlag]=runMonitorFEBio(FEBioRunStruct);%START FEBio NOW!!!!!!!!

%% IMPORTING NODAL DISPLACEMENT RESULTS
% Importing nodal displacements from a log file
[~, N_disp_mat,~]=importFEBio_logfile(fullfile(savePath,FEB_struct.run_output_names{1})); %Nodal displacements
DN=N_disp_mat(:,2:end,end); %Final nodal displacements

%Import deformation gradient tensors
[~,FG_mat,~]=importFEBio_logfile(fullfile(savePath,FEB_struct.run_output_names{2})); %Deformation gradient tensors
FG=FG_mat(:,2:end,end);

%% CREATING NODE SET IN DEFORMED STATE
VT_def=VT+DN;

%%
% Plotting the FEA results

hf=cFigure;
subplot(1,2,1);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;
C=sqrt(sum(DN.^2,2)); %Color towards displacement magnitude
hps=patch('Faces',FT,'Vertices',VT_def,'FaceColor','flat','CData',C,'lineWidth',edgeWidth,'edgeColor',edgeColor);
view(3); axis tight;  axis equal;  grid on;
camlight headlight;
set(gca,'FontSize',fontSize);

subplot(1,2,2);
title('Cut view of deformed model showing internal results','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize); hold on;

%Selecting half of the model to see interior
Z=VT(:,3); ZE=mean(Z(E),2);
L=ZE<mean(Z);
[Fs,~]=element2patch(E(L,:),[]);
Cs=sqrt(sum(DN.^2,2)); %Color towards displacement magnitude

hps=patch('Faces',Fs,'Vertices',VT_def,'FaceColor','flat','FaceVertexCData',Cs);

view(3); axis tight;  axis equal;  grid on;
colormap(cMap); colorbar; 
camlight headlight;
set(gca,'FontSize',fontSize);
drawnow;

%% DERIVE FIBRE DIRECTIONS IN DEFORMED STATE

%Compute coordinates at the centre of elements for fibre origings
X=VT_def(:,1); Y=VT_def(:,2); Z=VT_def(:,3);
XE=mean(X(E),2); YE=mean(Y(E),2); ZE=mean(Z(E),2);
VE_def=[XE(:) YE(:) ZE(:)];

VF_def=VF;
for q=1:1:size(E,1) 
    
    fg=reshape(FG(q,:),3,3)';
    
    vn=vecnormalize(fg*VF(q,:)')'; %Mapped/stretched vector
    VF_def(q,:)=vn;
end

%Create patch data for fibres
[Ff_def,Vf_def,Cf_def]=quiver3Dpatch(VE_def(:,1),VE_def(:,2),VE_def(:,3),VF_def(:,1),VF_def(:,2),VF_def(:,3),ones(size(VF_def,1),1),[1 1]);

%%
% Plotting the example model
hf1=cFigure;
title('Fibre directions in the deformed state','FontSize',fontSize);
xlabel('X','FontSize',fontSize);ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;
hp=patch('Faces',Fb,'Vertices',VT_def,'EdgeColor','none','FaceColor','flat','CData',Cb,'FaceAlpha',faceAlpha2);
hp=patch('Faces',Ff_def,'Vertices',Vf_def,'EdgeColor','none','FaceColor','k');
% plotV(VE,'k.');
axis equal; view(3); axis tight;  grid on; set(gca,'FontSize',fontSize);
colormap(cMap); colorbar; 
set(gca,'FontSize',fontSize);
drawnow;

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>
 
%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2017  Kevin Mattheus Moerman
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>